#!/bin/bash
# Update current checks hash on catalog branch
# This script is run when checks are modified on main branch to ensure
# the catalog branch reflects the current check suite for staleness detection
#
# Usage:
#   update-checks-hash.sh           - Full workflow (generate + commit to catalog)
#   update-checks-hash.sh --hash-only - Just output the hash to stdout

set -euo pipefail

# Parse arguments
HASH_ONLY=0
if [ "${1:-}" = "--hash-only" ]; then
    HASH_ONLY=1
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ACTION_DIR="$(dirname "$SCRIPT_DIR")"
REPO_ROOT="$(dirname "$ACTION_DIR")"
CHECKS_DIR="$REPO_ROOT/checks"

if [ "$HASH_ONLY" -eq 0 ]; then
    echo -e "${BLUE}Updating checks hash on catalog branch...${NC}"
    echo
fi

# ============================================================================
# Validate Environment
# ============================================================================

if [ ! -d "$CHECKS_DIR" ]; then
    echo -e "${RED}Error: Checks directory not found at $CHECKS_DIR${NC}"
    exit 1
fi

# ============================================================================
# Generate Checks Hash
# ============================================================================

if [ "$HASH_ONLY" -eq 0 ]; then
    echo "Generating hash from checks directory: $CHECKS_DIR"
fi

# Find all checks in sorted order
CHECK_DIRS=$(find "$CHECKS_DIR" -mindepth 1 -maxdepth 1 -type d | sort)

# Generate hash for each check (metadata + implementation)
CHECK_HASHES=""
CHECKS_COUNT=0

for check_dir in $CHECK_DIRS; do
    check_id=$(basename "$check_dir")

    # Hash metadata.json
    metadata_hash=""
    if [ -f "$check_dir/metadata.json" ]; then
        metadata_hash=$(sha256sum "$check_dir/metadata.json" | awk '{print $1}')
    fi

    # Hash check implementation (sh, py, or js)
    impl_hash=""
    if [ -f "$check_dir/check.sh" ]; then
        impl_hash=$(sha256sum "$check_dir/check.sh" | awk '{print $1}')
    elif [ -f "$check_dir/check.py" ]; then
        impl_hash=$(sha256sum "$check_dir/check.py" | awk '{print $1}')
    elif [ -f "$check_dir/check.js" ]; then
        impl_hash=$(sha256sum "$check_dir/check.js" | awk '{print $1}')
    fi

    # Combine check_id, metadata hash, and implementation hash
    check_combined="${check_id}:${metadata_hash}:${impl_hash}"
    CHECK_HASHES="${CHECK_HASHES}${check_combined}"$'\n'

    CHECKS_COUNT=$((CHECKS_COUNT + 1))
done

# Generate final hash from all check hashes
CHECKS_HASH=$(echo -n "$CHECK_HASHES" | sha256sum | awk '{print $1}')

# If hash-only mode, just output the hash and exit
if [ "$HASH_ONLY" -eq 1 ]; then
    echo "$CHECKS_HASH"
    exit 0
fi

echo "Checks count: $CHECKS_COUNT"
echo "Checks hash: $CHECKS_HASH"
echo

# ============================================================================
# Update Catalog Branch
# ============================================================================

# Get current branch name to return to it later
ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Stash any uncommitted changes
if ! git diff-index --quiet HEAD --; then
    echo "Stashing uncommitted changes..."
    git stash push -m "Auto-stash before updating checks hash"
    STASHED=1
else
    STASHED=0
fi

# Switch to catalog branch
echo -e "${BLUE}Switching to catalog branch...${NC}"
git fetch origin catalog:catalog 2>/dev/null || true
git checkout catalog

# Write current checks hash files
echo "$CHECKS_HASH" > "current-checks-hash.txt"
jq -n --arg hash "$CHECKS_HASH" --argjson count "$CHECKS_COUNT" '{
    checks_hash: $hash,
    checks_count: $count,
    generated_at: (now | todate)
}' > "current-checks.json"

# Commit if files changed
git add current-checks.json current-checks-hash.txt

if ! git diff --staged --quiet; then
    echo -e "${BLUE}Check suite changed - committing metadata...${NC}"
    git commit -m "Update check suite metadata

Checks hash: $CHECKS_HASH
Checks count: $CHECKS_COUNT

Auto-generated by update-checks-hash.sh"

    echo -e "${BLUE}Pushing to catalog branch...${NC}"
    if git push origin catalog; then
        echo -e "${GREEN}✓${NC} Check suite metadata updated successfully"
    else
        echo -e "${RED}✗ Failed to push check suite metadata${NC}"
        exit 1
    fi
else
    echo "Check suite unchanged - no update needed"
fi

# Return to original branch
echo -e "${BLUE}Returning to $ORIGINAL_BRANCH branch...${NC}"
git checkout "$ORIGINAL_BRANCH"

# Restore stashed changes if any
if [ "$STASHED" -eq 1 ]; then
    echo "Restoring stashed changes..."
    git stash pop
fi

echo
echo -e "${GREEN}✓ Checks hash update complete!${NC}"
echo "Services with old hash will now be marked as STALE in the catalog."
