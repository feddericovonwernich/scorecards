// Scorecards Catalog App

// Configuration
const REPO_OWNER = window.location.hostname.split('.')[0] || 'your-org';
const REPO_NAME = 'scorecards';
const BRANCH = 'catalog';
const RAW_BASE_URL = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}`;

// State
let allServices = [];
let filteredServices = [];
let activeFilters = new Map(); // Multi-select filters: filter -> 'include' | 'exclude'
let currentSort = 'score-desc';
let searchQuery = '';
let currentChecksHash = null;
let checksHashTimestamp = 0;

// GitHub PAT State (in-memory only)
let githubPAT = null;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    // Load services on page load (errors are handled and displayed by loadServices)
    loadServices().catch(() => {
        // Error already handled and displayed by loadServices()
    });
    setupEventListeners();
});

// ============================================================================
// Staleness Detection Functions
// ============================================================================

// Fetch current checks hash from catalog (generated by action)
// This uses a single source of truth instead of duplicating hash logic
async function fetchCurrentChecksHash() {
    const now = Date.now();
    const CACHE_TTL = 10 * 1000; // 10 seconds

    // Return cached value if still valid
    if (currentChecksHash && (now - checksHashTimestamp) < CACHE_TTL) {
        console.log('Using cached checks hash:', currentChecksHash);
        return currentChecksHash;
    }

    console.log('Fetching current checks hash from catalog...');

    try {
        // Fetch the pre-computed hash from the catalog branch
        // This is generated by the GitHub Action to ensure consistency
        const hashUrl = `${RAW_BASE_URL}/current-checks.json?t=${Date.now()}`;
        const response = await fetch(hashUrl, { cache: 'no-cache' });

        if (!response.ok) {
            console.error('Failed to fetch current checks hash:', response.status);
            return null;
        }

        const data = await response.json();
        const hash = data.checks_hash;

        // Update cache
        currentChecksHash = hash;
        checksHashTimestamp = now;

        console.log('Current checks hash:', hash);
        console.log('Checks count:', data.checks_count);
        console.log('Generated at:', data.generated_at);
        return hash;

    } catch (error) {
        console.error('Error fetching current checks hash:', error);
        return null;
    }
}

// Check if a service is stale (missing newer checks)
function isServiceStale(service, currentHash) {
    // If no current hash available, can't determine staleness
    if (!currentHash) {
        return false;
    }

    // Backwards compatibility: if service has no checks_hash, assume it's stale
    if (!service.checks_hash) {
        return true;
    }

    // Compare hashes
    return service.checks_hash !== currentHash;
}

// Format timestamp as relative time (e.g., "2 minutes ago")
function formatRelativeTime(timestamp) {
    if (!timestamp) return 'Unknown';

    const now = new Date();
    const date = new Date(timestamp);
    const seconds = Math.floor((now - date) / 1000);

    if (seconds < 60) return 'Just now';
    if (seconds < 3600) {
        const minutes = Math.floor(seconds / 60);
        return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
    }
    if (seconds < 86400) {
        const hours = Math.floor(seconds / 3600);
        return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
    }
    if (seconds < 604800) {
        const days = Math.floor(seconds / 86400);
        return `${days} day${days !== 1 ? 's' : ''} ago`;
    }

    // For older dates, show the actual date
    return date.toLocaleDateString();
}

// Setup Event Listeners
function setupEventListeners() {
    // Search
    document.getElementById('search-input').addEventListener('input', (e) => {
        searchQuery = e.target.value.toLowerCase();
        filterAndRenderServices();
    });

    // Filterable stat cards (multi-select with include/exclude)
    document.querySelectorAll('.stat-card.filterable').forEach(card => {
        card.addEventListener('click', () => {
            const filter = card.dataset.filter;

            // Cycle through states: null -> include -> exclude -> null
            const currentState = activeFilters.get(filter);

            // Remove existing classes
            card.classList.remove('active', 'exclude');

            if (!currentState) {
                // Null -> Include
                activeFilters.set(filter, 'include');
                card.classList.add('active');
            } else if (currentState === 'include') {
                // Include -> Exclude
                activeFilters.set(filter, 'exclude');
                card.classList.add('exclude');
            } else {
                // Exclude -> Null
                activeFilters.delete(filter);
            }

            filterAndRenderServices();
        });
    });

    // Sort
    document.getElementById('sort-select').addEventListener('change', (e) => {
        currentSort = e.target.value;
        filterAndRenderServices();
    });

    // Modal close
    document.querySelector('.modal-close').addEventListener('click', closeModal);
    document.getElementById('service-modal').addEventListener('click', (e) => {
        if (e.target.id === 'service-modal') {
            closeModal();
        }
    });

    // Modal close on Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const modal = document.getElementById('service-modal');
            if (modal && !modal.classList.contains('hidden')) {
                closeModal();
            }
        }
    });
}

// Load Services from Registry
async function loadServices() {
    try {
        let loadedFromConsolidated = false;
        let usedAPI = false;

        // Try to load consolidated registry first (no API rate limits via CDN)
        try {
            console.log('Attempting to load consolidated registry...');
            const { response, usedAPI: fetchUsedAPI } = await fetchWithHybridAuth('registry/all-services.json');
            usedAPI = fetchUsedAPI;

            if (response.ok) {
                const registryData = await response.json();
                if (registryData.services && Array.isArray(registryData.services)) {
                    allServices = registryData.services;
                    filteredServices = [...allServices];
                    loadedFromConsolidated = true;
                    console.log(`Loaded ${allServices.length} services from consolidated registry (generated at ${registryData.generated_at})`);
                }
            }
        } catch (error) {
            console.warn('Failed to load consolidated registry, falling back to tree API:', error);
        }

        // Fallback: Use tree API to discover individual files (backward compatibility)
        if (!loadedFromConsolidated) {
            console.log('Loading services via tree API...');
            const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
            const response = await fetch(apiUrl);

            if (!response.ok) {
                throw new Error(`Failed to fetch repository tree: ${response.status}`);
            }

            const treeData = await response.json();

            // Find all registry JSON files (registry/$org/$repo.json), excluding all-services.json
            const registryFiles = treeData.tree
                .filter(item =>
                    item.path.startsWith('registry/') &&
                    item.path.endsWith('.json') &&
                    item.path !== 'registry/all-services.json'
                )
                .map(item => item.path);

            if (registryFiles.length === 0) {
                throw new Error('No services registered yet');
            }

            // Fetch all registry files in parallel using hybrid approach
            const fetchPromises = registryFiles.map(async (path) => {
                const { response, usedAPI: fetchUsedAPI } = await fetchWithHybridAuth(path);
                if (fetchUsedAPI) usedAPI = true; // Track if any fetch used API
                if (response.ok) {
                    return response.json();
                }
                return null;
            });

            const results = await Promise.all(fetchPromises);
            allServices = results.filter(service => service !== null);
            filteredServices = [...allServices];
            console.log(`Loaded ${allServices.length} services via tree API`);
        }

        // Fetch current checks hash for staleness detection
        await fetchCurrentChecksHash();

        updateStats();
        filterAndRenderServices();

        // Return whether API was used for data freshness indication
        return { usedAPI };
    } catch (error) {
        console.error('Error loading services:', error);
        document.getElementById('services-grid').innerHTML = `
            <div class="empty-state">
                <h3>No Services Found</h3>
                <p>No services have run scorecards yet, or the registry is not available.</p>
                <p style="margin-top: 10px; font-size: 0.9rem; color: #999;">
                    Error: ${error.message}
                </p>
            </div>
        `;
        // Re-throw to allow callers (like refreshData) to detect failure
        throw error;
    }
}

// Refresh data (re-fetch from catalog; uses GitHub API with PAT, otherwise CDN)
async function refreshData() {
    const refreshBtn = document.getElementById('refresh-btn');

    if (!refreshBtn) return;

    // Disable button and show loading state
    const originalText = refreshBtn.innerHTML;
    refreshBtn.disabled = true;
    refreshBtn.innerHTML = '<span class="spinner"></span> Refreshing...';

    try {
        // Show toast notification
        showToast('Refreshing service data...', 'info');

        // Clear checks hash cache to force refetch
        currentChecksHash = null;
        checksHashTimestamp = 0;

        // Reload all services
        const { usedAPI } = await loadServices();

        // Show appropriate success message based on data source
        const timestamp = new Date().toLocaleTimeString();
        if (usedAPI) {
            showToast(`Data refreshed successfully from GitHub API at ${timestamp}. (Fresh data, bypassed cache)`, 'success');
        } else {
            showToast(`Data refreshed from CDN at ${timestamp}. (Note: CDN cache may be up to 5 minutes old. Use GitHub PAT in settings for real-time data)`, 'success');
        }
    } catch (error) {
        console.error('Error refreshing data:', error);
        showToast(`Failed to refresh data: ${error.message}`, 'error');
    } finally {
        // Restore button state
        setTimeout(() => {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = originalText;
        }, 1000);
    }
}

// Update Statistics
function updateStats() {
    const total = allServices.length;
    const avgScore = total > 0
        ? Math.round(allServices.reduce((sum, s) => sum + s.score, 0) / total)
        : 0;

    const rankCounts = {
        platinum: allServices.filter(s => s.rank === 'platinum').length,
        gold: allServices.filter(s => s.rank === 'gold').length,
        silver: allServices.filter(s => s.rank === 'silver').length,
        bronze: allServices.filter(s => s.rank === 'bronze').length
    };

    const apiCount = allServices.filter(s => s.has_api).length;
    const staleCount = allServices.filter(s => isServiceStale(s, currentChecksHash)).length;
    const installedCount = allServices.filter(s => s.installed).length;

    document.getElementById('total-services').textContent = total;
    document.getElementById('avg-score').textContent = avgScore;
    document.getElementById('api-count').textContent = apiCount;
    document.getElementById('stale-count').textContent = staleCount;
    document.getElementById('installed-count').textContent = installedCount;
    document.getElementById('platinum-count').textContent = rankCounts.platinum;
    document.getElementById('gold-count').textContent = rankCounts.gold;
    document.getElementById('silver-count').textContent = rankCounts.silver;
    document.getElementById('bronze-count').textContent = rankCounts.bronze;
}

// Filter and Render Services
function filterAndRenderServices() {
    // Filter
    filteredServices = allServices.filter(service => {
        // Multi-select filters with include/exclude (AND logic)
        if (activeFilters.size > 0) {
            for (const [filterName, filterState] of activeFilters) {
                // Determine if service matches this filter
                let matches = false;

                if (filterName === 'has-api') {
                    matches = service.has_api;
                } else if (filterName === 'stale') {
                    matches = isServiceStale(service, currentChecksHash);
                } else if (filterName === 'installed') {
                    matches = service.installed;
                } else if (filterName === 'platinum' || filterName === 'gold' || filterName === 'silver' || filterName === 'bronze') {
                    matches = service.rank === filterName;
                }

                // Apply include/exclude logic
                if (filterState === 'include') {
                    // Include: service must match
                    if (!matches) {
                        return false;
                    }
                } else if (filterState === 'exclude') {
                    // Exclude: service must NOT match
                    if (matches) {
                        return false;
                    }
                }
            }
        }

        // Search filter
        if (searchQuery) {
            const searchText = `${service.name} ${service.org} ${service.repo} ${service.team || ''}`.toLowerCase();
            if (!searchText.includes(searchQuery)) {
                return false;
            }
        }

        return true;
    });

    // Sort
    filteredServices.sort((a, b) => {
        switch (currentSort) {
            case 'score-desc':
                return b.score - a.score;
            case 'score-asc':
                return a.score - b.score;
            case 'name-asc':
                return a.name.localeCompare(b.name);
            case 'name-desc':
                return b.name.localeCompare(a.name);
            case 'updated-desc':
                return new Date(b.last_updated) - new Date(a.last_updated);
            default:
                return 0;
        }
    });

    renderServices();
}

// Render Services Grid
function renderServices() {
    const grid = document.getElementById('services-grid');

    if (filteredServices.length === 0) {
        grid.innerHTML = '<div class="empty-state"><h3>No services match your criteria</h3></div>';
        return;
    }

    grid.innerHTML = filteredServices.map(service => {
        const isStale = isServiceStale(service, currentChecksHash);
        const canTrigger = isStale && service.installed;
        return `
        <div class="service-card rank-${service.rank}" onclick="showServiceDetail('${service.org}', '${service.repo}')">
            <div class="service-header">
                <div>
                    <div class="service-title-wrapper">
                        <div class="service-name">${escapeHtml(service.name)}</div>
                        <div class="service-badges">
                            ${service.has_api ? '<span class="badge-api">API</span>' : ''}
                            ${isStale ? '<span class="badge-stale">STALE</span>' : ''}
                            ${service.installed ? '<span class="badge-installed">INSTALLED</span>' : ''}
                        </div>
                    </div>
                    <div class="service-org">${escapeHtml(service.org)}/${escapeHtml(service.repo)}</div>
                </div>
                <div style="display: flex; align-items: center; gap: 12px;">
                    ${canTrigger ? `
                    <button
                        class="trigger-btn trigger-btn-icon"
                        onclick="event.stopPropagation(); triggerServiceWorkflow('${escapeHtml(service.org)}', '${escapeHtml(service.repo)}', this)"
                        title="Re-run scorecard workflow">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"></path>
                        </svg>
                    </button>
                    ` : ''}
                    <a href="https://github.com/${escapeHtml(service.org)}/${escapeHtml(service.repo)}"
                       target="_blank"
                       rel="noopener noreferrer"
                       class="github-icon-link"
                       onclick="event.stopPropagation()"
                       title="View on GitHub">
                        <svg width="18" height="18" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                        </svg>
                    </a>
                    ${!service.installed && service.installation_pr ? `
                    <a href="${escapeHtml(service.installation_pr.url)}"
                       target="_blank"
                       rel="noopener noreferrer"
                       class="pr-icon-link pr-icon-${service.installation_pr.state.toLowerCase()}"
                       onclick="event.stopPropagation()"
                       title="${service.installation_pr.state === 'OPEN' ? 'Open installation PR' : 'Closed installation PR'} #${service.installation_pr.number}">
                        <svg width="18" height="18" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M1.5 3.25a2.25 2.25 0 1 1 3 2.122v5.256a2.251 2.251 0 1 1-1.5 0V5.372A2.25 2.25 0 0 1 1.5 3.25Zm5.677-.177L9.573.677A.25.25 0 0 1 10 .854V2.5h1A2.5 2.5 0 0 1 13.5 5v5.628a2.251 2.251 0 1 1-1.5 0V5a1 1 0 0 0-1-1h-1v1.646a.25.25 0 0 1-.427.177L7.177 3.427a.25.25 0 0 1 0-.354ZM3.75 2.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm0 9.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm8.25.75a.75.75 0 1 0 1.5 0 .75.75 0 0 0-1.5 0Z"/>
                        </svg>
                    </a>
                    ` : ''}
                    <div class="score-badge">${service.score}</div>
                </div>
            </div>
            <div class="rank-badge ${service.rank}">${capitalize(service.rank)}</div>
            ${service.team ? `<div>Team: ${escapeHtml(service.team)}</div>` : ''}
            <div class="service-meta">
                <div>Last updated: ${formatDate(service.last_updated)}</div>
                ${service.installation_pr && service.installation_pr.updated_at ? `
                <div class="pr-status-timestamp" title="PR status last fetched at ${new Date(service.installation_pr.updated_at).toLocaleString()}">
                    PR status: ${formatRelativeTime(service.installation_pr.updated_at)}
                </div>
                ` : ''}
            </div>
        </div>
    `;
    }).join('');
}

// Show Service Detail Modal
async function showServiceDetail(org, repo) {
    const modal = document.getElementById('service-modal');
    const detailDiv = document.getElementById('service-detail');

    // Store current service context for workflow runs
    currentServiceOrg = org;
    currentServiceRepo = repo;
    serviceWorkflowLoaded = false;

    modal.classList.remove('hidden');
    detailDiv.innerHTML = '<div class="loading">Loading service details...</div>';

    try {
        // Fetch both results and registry in parallel using hybrid approach
        const resultsPath = `results/${org}/${repo}/results.json`;
        const registryPath = `registry/${org}/${repo}.json`;

        const [resultsData, registryData] = await Promise.all([
            fetchWithHybridAuth(resultsPath),
            fetchWithHybridAuth(registryPath)
        ]);

        const resultsRes = resultsData.response;
        const registryRes = registryData.response;

        if (!resultsRes.ok) {
            throw new Error(`Failed to fetch results: ${resultsRes.status}`);
        }

        const data = await resultsRes.json();

        // Merge installation_pr from registry if available
        if (registryRes.ok) {
            const registry = await registryRes.json();
            if (registry.installation_pr) {
                data.installation_pr = registry.installation_pr;
            }
        }

        // Check staleness
        const isStale = isServiceStale(data, currentChecksHash);
        const canTrigger = isStale && data.installed;
        const stalenessWarning = isStale ? `
            <div style="background: #fff3cd; border: 1px solid #f39c12; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                    <div style="flex: 1;">
                        <strong style="color: #856404;">Scorecard is Stale</strong>
                        <p style="margin: 5px 0 0 0; color: #856404;">
                            This scorecard was generated with an older version of the check suite.
                            New checks may have been added or existing checks may have been modified.
                            ${canTrigger ? 'Click the "Re-run Scorecard" button to get up-to-date results.' : 'Re-run the scorecard workflow to get up-to-date results.'}
                        </p>
                    </div>
                    ${canTrigger ? `
                    <button
                        id="modal-trigger-btn"
                        class="trigger-btn"
                        onclick="triggerServiceWorkflow('${escapeHtml(org)}', '${escapeHtml(repo)}', this)"
                        style="margin-left: auto;">
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="margin-right: 6px;">
                            <path d="M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"></path>
                        </svg>
                        Re-run Scorecard
                    </button>
                    ` : ''}
                </div>
            </div>
        ` : '';

        detailDiv.innerHTML = `
            <div class="rank-badge modal-header-badge ${data.rank}">
                ${capitalize(data.rank)}
            </div>

            <h2>${escapeHtml(data.service.name)}</h2>
            <p style="color: #7f8c8d; margin-bottom: 10px;">
                ${escapeHtml(data.service.org)}/${escapeHtml(data.service.repo)}
            </p>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <a href="https://github.com/${escapeHtml(data.service.org)}/${escapeHtml(data.service.repo)}"
                   target="_blank"
                   rel="noopener noreferrer"
                   class="github-button">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    View on GitHub
                </a>
                <button
                    id="modal-refresh-btn"
                    class="github-button"
                    onclick="refreshServiceData('${escapeHtml(org)}', '${escapeHtml(repo)}')"
                    title="Refresh service data">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"></path>
                    </svg>
                    Refresh Data
                </button>
                ${!data.installed && data.installation_pr && data.installation_pr.state === 'OPEN' ? `
                <a href="${escapeHtml(data.installation_pr.url)}"
                   target="_blank"
                   rel="noopener noreferrer"
                   class="pr-button pr-button-open">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M1.5 3.25a2.25 2.25 0 1 1 3 2.122v5.256a2.251 2.251 0 1 1-1.5 0V5.372A2.25 2.25 0 0 1 1.5 3.25Zm5.677-.177L9.573.677A.25.25 0 0 1 10 .854V2.5h1A2.5 2.5 0 0 1 13.5 5v5.628a2.251 2.251 0 1 1-1.5 0V5a1 1 0 0 0-1-1h-1v1.646a.25.25 0 0 1-.427.177L7.177 3.427a.25.25 0 0 1 0-.354ZM3.75 2.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm0 9.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm8.25.75a.75.75 0 1 0 1.5 0 .75.75 0 0 0-1.5 0Z"/>
                    </svg>
                    Open Installation PR #${data.installation_pr.number}
                </a>
                ` : ''}
                ${!data.installed && (!data.installation_pr || data.installation_pr.state === 'MERGED' || data.installation_pr.state === 'CLOSED') ? `
                <button
                    id="install-btn"
                    class="install-button"
                    onclick="installService('${escapeHtml(org)}', '${escapeHtml(repo)}', this)"
                    title="${data.installation_pr ? `Previous PR #${data.installation_pr.number} was ${data.installation_pr.state.toLowerCase()}` : 'Create installation PR'}">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="margin-right: 6px;">
                        <path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z"></path>
                        <path d="M7.25 7.689V2a.75.75 0 0 1 1.5 0v5.689l1.97-1.969a.749.749 0 1 1 1.06 1.06l-3.25 3.25a.749.749 0 0 1-1.06 0L4.22 6.78a.749.749 0 1 1 1.06-1.06l1.97 1.969Z"></path>
                    </svg>
                    Install Scorecards
                </button>
                ` : ''}
            </div>

            ${stalenessWarning}

            <div class="modal-stats-container">
                <div class="modal-stat-item">
                    <div class="modal-stat-value">${data.score}</div>
                    <div class="modal-stat-label">Score</div>
                </div>
                <div class="modal-stat-item">
                    <div class="modal-stat-value">${data.passed_checks}/${data.total_checks}</div>
                    <div class="modal-stat-label">Checks Passed</div>
                </div>
            </div>

            ${data.service.team ? `<p><strong>Team:</strong> ${escapeHtml(data.service.team)}</p>` : ''}
            <p><strong>Last Run:</strong> ${formatDate(data.timestamp)}</p>
            <p><strong>Commit:</strong> <code>${data.commit_sha.substring(0, 7)}</code></p>
            ${data.installation_pr && data.installation_pr.updated_at ? `
            <p><strong>PR Status Updated:</strong> ${formatRelativeTime(data.installation_pr.updated_at)}
                <span style="color: #999; font-size: 0.9em;" title="${new Date(data.installation_pr.updated_at).toLocaleString()}">(${new Date(data.installation_pr.updated_at).toLocaleString()})</span>
            </p>
            ` : ''}

            <div class="tabs" style="margin-top: 30px;">
                <button class="tab-btn active" onclick="switchTab(event, 'checks')">Check Results</button>
                ${data.service.openapi ? '<button class="tab-btn" onclick="switchTab(event, \'api\')">API Specification</button>' : ''}
                ${data.service.links && data.service.links.length > 0 ? `<button class="tab-btn" onclick="switchTab(event, 'links')">Links (${data.service.links.length})</button>` : ''}
                ${data.recent_contributors && data.recent_contributors.length > 0 ? '<button class="tab-btn" onclick="switchTab(event, \'contributors\')">Contributors</button>' : ''}
                <button class="tab-btn" onclick="switchTab(event, 'workflows')">Workflow Runs</button>
                <button class="tab-btn" onclick="switchTab(event, 'badges')">Badges</button>
            </div>

            <div class="tab-content active" id="checks-tab">
                <div>
                    ${data.checks.map(check => `
                        <div class="check-result ${check.status}">
                            <div class="check-name">
                                ${check.status === 'pass' ? '‚úì' : '‚úó'} ${escapeHtml(check.name)}
                            </div>
                            <div class="check-description">${escapeHtml(check.description)}</div>
                            ${check.stdout.trim() ? `
                                <div class="check-output">
                                    <strong>Output:</strong><br>
                                    ${escapeHtml(check.stdout.trim())}
                                </div>
                            ` : ''}
                            ${check.stderr.trim() && check.status === 'fail' ? `
                                <div class="check-output" style="color: #c62828;">
                                    <strong>Error:</strong><br>
                                    ${escapeHtml(check.stderr.trim())}
                                </div>
                            ` : ''}
                            <div style="margin-top: 8px; font-size: 0.85rem; color: #999;">
                                Weight: ${check.weight} | Duration: ${check.duration}s
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>

            ${data.service.openapi ? `
                <div class="tab-content" id="api-tab">
                    <div style="margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">OpenAPI Specification</h3>
                        ${data.service.openapi.spec_file ? `<p><strong>Spec File:</strong> <code>${escapeHtml(data.service.openapi.spec_file)}</code></p>` : ''}

                        ${data.service.openapi.environments ? `
                            <h4 style="margin-top: 20px; margin-bottom: 10px;">Environments</h4>
                            <div style="display: grid; gap: 12px;">
                                ${Object.entries(data.service.openapi.environments).map(([envName, envConfig]) => `
                                    <div style="border: 1px solid #e1e4e8; border-radius: 8px; padding: 15px; background: #f6f8fa;">
                                        <div style="font-weight: bold; margin-bottom: 5px; text-transform: capitalize;">${escapeHtml(envName)}</div>
                                        <div style="font-family: monospace; font-size: 0.9rem; color: #0366d6; margin-bottom: 5px;">
                                            ${escapeHtml(envConfig.base_url)}
                                        </div>
                                        ${envConfig.description ? `<div style="font-size: 0.85rem; color: #586069;">${escapeHtml(envConfig.description)}</div>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}

                        <div style="margin-top: 20px;">
                            <button
                                onclick="openApiExplorer('${escapeHtml(org)}', '${escapeHtml(repo)}')"
                                style="background: #0366d6; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; font-weight: 500;"
                                onmouseover="this.style.background='#0256c2'"
                                onmouseout="this.style.background='#0366d6'"
                            >
                                üîç Open API Explorer
                            </button>
                            <p style="margin-top: 10px; font-size: 0.85rem; color: #586069;">
                                Explore and test the API with an interactive Swagger UI interface
                            </p>
                        </div>
                    </div>
                </div>
            ` : ''}

            ${data.service.links && data.service.links.length > 0 ? `
                <div class="tab-content" id="links-tab">
                    <ul class="link-list">
                        ${data.service.links.map(link => `
                            <li class="link-item">
                                <a href="${escapeHtml(link.url)}" target="_blank" rel="noopener noreferrer">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="flex-shrink: 0; margin-right: 8px;">
                                        <path d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path>
                                    </svg>
                                    <div class="link-content">
                                        <strong class="link-name">${escapeHtml(link.name)}</strong>
                                        ${link.description ? `<p class="link-description">${escapeHtml(link.description)}</p>` : ''}
                                    </div>
                                </a>
                            </li>
                        `).join('')}
                    </ul>
                </div>
            ` : ''}

            ${data.recent_contributors && data.recent_contributors.length > 0 ? `
                <div class="tab-content" id="contributors-tab">
                    <h4 style="margin-top: 0; margin-bottom: 15px; font-size: 1rem; color: #2c3e50;">
                        Recent Contributors (Last 20 Commits)
                    </h4>
                    <p style="margin-bottom: 20px; color: #7f8c8d; font-size: 0.9rem;">
                        Contributors who have committed to this repository recently, ordered by commit count.
                    </p>
                    <div class="contributors-list">
                        ${data.recent_contributors.map(contributor => {
                            // Generate MD5 hash of email for Gravatar
                            const emailHash = md5(contributor.email.toLowerCase().trim());
                            const avatarUrl = `https://www.gravatar.com/avatar/${emailHash}?d=identicon&s=48`;

                            // Extract potential GitHub username from email
                            const githubUsername = contributor.email.split('@')[0].replace(/[^a-zA-Z0-9-]/g, '');
                            const isGithubEmail = contributor.email.includes('github') || contributor.email.includes('users.noreply.github.com');

                            return `
                                <div class="contributor-item">
                                    <img src="${avatarUrl}"
                                         alt="${escapeHtml(contributor.name)}"
                                         class="contributor-avatar"
                                         onerror="this.src='https://www.gravatar.com/avatar/00000000000000000000000000000000?d=mp&s=48'"
                                    >
                                    <div class="contributor-info">
                                        <div class="contributor-name">
                                            <strong>${escapeHtml(contributor.name)}</strong>
                                            ${isGithubEmail ?
                                                `<a href="https://github.com/${githubUsername}"
                                                    target="_blank"
                                                    rel="noopener noreferrer"
                                                    class="contributor-github-link"
                                                    title="View GitHub profile">
                                                    <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                                                    </svg>
                                                </a>`
                                                : ''}
                                        </div>
                                        <div class="contributor-email">${escapeHtml(contributor.email)}</div>
                                        <div class="contributor-meta">
                                            <span class="contributor-commits" title="${contributor.commit_count} commit${contributor.commit_count !== 1 ? 's' : ''}">
                                                <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle; margin-right: 4px;">
                                                    <path d="M1.643 3.143.427 1.927A.25.25 0 0 1 .604 1.5h6.792a.25.25 0 0 1 .177.427L6.357 3.143a.25.25 0 0 1-.177.073H1.82a.25.25 0 0 1-.177-.073ZM2.976 7.5A2.5 2.5 0 0 1 0 7.5v-2a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v2a2.5 2.5 0 0 1-2.024 0Zm1.524-.5h-3v.25a1.5 1.5 0 0 0 3 0V7ZM8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Z"></path>
                                                </svg>
                                                ${contributor.commit_count} commit${contributor.commit_count !== 1 ? 's' : ''}
                                            </span>
                                            <span class="contributor-date" title="${new Date(contributor.last_commit_date).toLocaleString()}">
                                                Last commit: ${formatDate(contributor.last_commit_date)}
                                            </span>
                                            <span class="contributor-hash">
                                                <code>${contributor.last_commit_hash}</code>
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            ` : ''}

            <div class="tab-content" id="workflows-tab">
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="widget-filters" style="margin: 0;">
                            <button class="widget-filter-btn active" data-status="all" onclick="filterServiceWorkflows('all')">
                                All <span class="filter-count" id="service-filter-count-all">0</span>
                            </button>
                            <button class="widget-filter-btn" data-status="in_progress" onclick="filterServiceWorkflows('in_progress')">
                                In Progress <span class="filter-count" id="service-filter-count-in_progress">0</span>
                            </button>
                            <button class="widget-filter-btn" data-status="queued" onclick="filterServiceWorkflows('queued')">
                                Queued <span class="filter-count" id="service-filter-count-queued">0</span>
                            </button>
                            <button class="widget-filter-btn" data-status="completed" onclick="filterServiceWorkflows('completed')">
                                Completed <span class="filter-count" id="service-filter-count-completed">0</span>
                            </button>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <select id="service-workflow-interval-select" class="widget-interval-select" onchange="changeServicePollingInterval()" title="Auto-refresh interval">
                                <option value="5000">5s</option>
                                <option value="10000">10s</option>
                                <option value="15000">15s</option>
                                <option value="30000" selected>30s</option>
                                <option value="60000">1m</option>
                                <option value="120000">2m</option>
                                <option value="300000">5m</option>
                                <option value="0">Off</option>
                            </select>
                            <button id="service-workflow-refresh" class="widget-refresh-btn" onclick="refreshServiceWorkflowRuns()" title="Refresh" style="padding: 6px 10px;">
                                <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                    <path d="M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                <div id="service-workflows-content">
                    <div class="loading">Click to load workflow runs...</div>
                </div>
            </div>

            <div class="tab-content" id="badges-tab">
                <h4 style="margin-top: 0; margin-bottom: 15px; font-size: 1rem; color: #2c3e50;">Badge Preview</h4>
                <div style="background: #f5f7fa; padding: 20px; border-radius: 8px; margin-bottom: 25px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <img src="https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/score.json" alt="Score Badge" style="height: 20px;">
                    <img src="https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/rank.json" alt="Rank Badge" style="height: 20px;">
                </div>

                <h4 style="margin-bottom: 10px; font-size: 1rem; color: #2c3e50;">Add to Your README</h4>
                <p style="font-size: 0.9rem; color: #7f8c8d; margin-bottom: 10px;">
                    Copy the markdown below:
                </p>

                <div style="position: relative; margin-bottom: 15px;">
                    <button onclick="copyBadgeCode('score-badge-${org}-${repo}', event)" style="position: absolute; right: 10px; top: 10px; background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; z-index: 1;" onmouseover="this.style.background='#2980b9'" onmouseout="this.style.background='#3498db'">Copy</button>
                    <pre id="score-badge-${org}-${repo}" style="background: #f5f7fa; padding: 15px; padding-right: 80px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; margin: 0;">![Score](https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/score.json)</pre>
                </div>

                <div style="position: relative;">
                    <button onclick="copyBadgeCode('rank-badge-${org}-${repo}', event)" style="position: absolute; right: 10px; top: 10px; background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; z-index: 1;" onmouseover="this.style.background='#2980b9'" onmouseout="this.style.background='#3498db'">Copy</button>
                    <pre id="rank-badge-${org}-${repo}" style="background: #f5f7fa; padding: 15px; padding-right: 80px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; margin: 0;">![Rank](https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/rank.json)</pre>
                </div>
            </div>
        `;

        // Initialize service workflow polling interval dropdown with saved preference
        const savedInterval = localStorage.getItem('service_workflow_poll_interval');
        if (savedInterval !== null) {
            serviceWorkflowPollIntervalTime = parseInt(savedInterval);
            const select = document.getElementById('service-workflow-interval-select');
            if (select) {
                select.value = savedInterval;
            }
        }

    } catch (error) {
        console.error('Error loading service details:', error);
        detailDiv.innerHTML = `
            <h3>Error Loading Details</h3>
            <p>Could not load details for ${org}/${repo}</p>
            <p style="color: #999; font-size: 0.9rem;">${error.message}</p>
        `;
    }
}

// Refresh service data in modal
async function refreshServiceData(org, repo) {
    const button = document.getElementById('modal-refresh-btn');
    if (!button) return;

    // Get current active tab to preserve state
    const activeTab = document.querySelector('.tab-btn.active');
    const activeTabName = activeTab ? activeTab.textContent.trim().toLowerCase().replace(/\s+/g, '-') : 'check-results';

    // Add spinning animation
    const svg = button.querySelector('svg');
    const originalContent = button.innerHTML;
    if (svg) {
        svg.style.animation = 'spin 1s linear infinite';
    }
    button.disabled = true;

    try {
        // Fetch both results and registry with cache bypass (like main refresh does)
        const resultsPath = `results/${org}/${repo}/results.json`;
        const registryPath = `registry/${org}/${repo}.json`;

        const [resultsData, registryData] = await Promise.all([
            fetchWithHybridAuth(resultsPath),
            fetchWithHybridAuth(registryPath)
        ]);

        const resultsRes = resultsData.response;
        const registryRes = registryData.response;

        if (!resultsRes.ok) {
            throw new Error(`Failed to fetch results: ${resultsRes.status}`);
        }

        const data = await resultsRes.json();

        // Merge installation_pr from registry if available
        if (registryRes.ok) {
            const registry = await registryRes.json();
            if (registry.installation_pr) {
                data.installation_pr = registry.installation_pr;
            }
        }

        // Re-render the modal (reuse showServiceDetail logic)
        const detailDiv = document.getElementById('service-detail');
        const modal = document.getElementById('service-modal');

        // Store current service context
        currentServiceOrg = org;
        currentServiceRepo = repo;

        // Don't reset serviceWorkflowLoaded - preserve workflow runs data
        // serviceWorkflowLoaded = false;

        // Check staleness
        const isStale = isServiceStale(data, currentChecksHash);
        const canTrigger = isStale && data.installed;
        const stalenessWarning = isStale ? `
            <div style="background: #fff3cd; border: 1px solid #f39c12; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                    <div style="flex: 1;">
                        <strong style="color: #856404;">Scorecard is Stale</strong>
                        <p style="margin: 5px 0 0 0; color: #856404;">
                            This scorecard was generated with an older version of the check suite.
                            New checks may have been added or existing checks may have been modified.
                            ${canTrigger ? 'Click the "Re-run Scorecard" button to get up-to-date results.' : 'Re-run the scorecard workflow to get up-to-date results.'}
                        </p>
                    </div>
                    ${canTrigger ? `
                    <button
                        id="modal-trigger-btn"
                        class="trigger-btn"
                        onclick="triggerServiceWorkflow('${escapeHtml(org)}', '${escapeHtml(repo)}', this)"
                        style="margin-left: auto;">
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor" style="margin-right: 6px;">
                            <path d="M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"></path>
                        </svg>
                        Re-run Scorecard
                    </button>
                    ` : ''}
                </div>
            </div>
        ` : '';

        // Regenerate the modal content (simplified version focusing on main sections)
        detailDiv.innerHTML = `
            <div class="rank-badge modal-header-badge ${data.rank}">
                ${capitalize(data.rank)}
            </div>

            <h2>${escapeHtml(data.service.name)}</h2>
            <p style="color: #7f8c8d; margin-bottom: 10px;">
                ${escapeHtml(data.service.org)}/${escapeHtml(data.service.repo)}
            </p>
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <a href="https://github.com/${escapeHtml(data.service.org)}/${escapeHtml(data.service.repo)}"
                   target="_blank"
                   rel="noopener noreferrer"
                   class="github-button">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    View on GitHub
                </a>
                <button
                    id="modal-refresh-btn"
                    class="github-button"
                    onclick="refreshServiceData('${escapeHtml(org)}', '${escapeHtml(repo)}')"
                    title="Refresh service data">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"></path>
                    </svg>
                    Refresh Data
                </button>
                ${!data.installed && data.installation_pr && data.installation_pr.state === 'OPEN' ? `
                <a href="${escapeHtml(data.installation_pr.url)}"
                   target="_blank"
                   rel="noopener noreferrer"
                   class="pr-button pr-button-open">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M1.5 3.25a2.25 2.25 0 1 1 3 2.122v5.256a2.251 2.251 0 1 1-1.5 0V5.372A2.25 2.25 0 0 1 1.5 3.25Zm5.677-.177L9.573.677A.25.25 0 0 1 10 .854V2.5h1A2.5 2.5 0 0 1 13.5 5v5.628a2.251 2.251 0 1 1-1.5 0V5a1 1 0 0 0-1-1h-1v1.646a.25.25 0 0 1-.427.177L7.177 3.427a.25.25 0 0 1 0-.354ZM3.75 2.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm0 9.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm8.25.75a.75.75 0 1 0 1.5 0 .75.75 0 0 0-1.5 0Z"/>
                    </svg>
                    Open Installation PR #${data.installation_pr.number}
                </a>
                ` : ''}
                ${!data.installed && (!data.installation_pr || data.installation_pr.state === 'MERGED' || data.installation_pr.state === 'CLOSED') ? `
                <button
                    id="install-btn"
                    class="install-button"
                    onclick="installService('${escapeHtml(org)}', '${escapeHtml(repo)}', this)"
                    title="${data.installation_pr ? `Previous PR #${data.installation_pr.number} was ${data.installation_pr.state.toLowerCase()}` : 'Create installation PR'}">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="margin-right: 6px;">
                        <path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z"></path>
                        <path d="M7.25 7.689V2a.75.75 0 0 1 1.5 0v5.689l1.97-1.969a.749.749 0 1 1 1.06 1.06l-3.25 3.25a.749.749 0 0 1-1.06 0L4.22 6.78a.749.749 0 1 1 1.06-1.06l1.97 1.969Z"></path>
                    </svg>
                    ${data.installation_pr ? 'Re-create' : 'Install'} Scorecards
                </button>
                ` : ''}
            </div>

            ${stalenessWarning}

            <div class="modal-stats-container">
                <div class="modal-stat-item">
                    <div class="modal-stat-value">${data.score}</div>
                    <div class="modal-stat-label">Score</div>
                </div>
                <div class="modal-stat-item">
                    <div class="modal-stat-value">${data.passed_checks}/${data.total_checks}</div>
                    <div class="modal-stat-label">Checks Passed</div>
                </div>
            </div>

            ${data.service.team ? `<p><strong>Team:</strong> ${escapeHtml(data.service.team)}</p>` : ''}
            <p><strong>Last Run:</strong> ${formatDate(data.timestamp)}</p>
            <p><strong>Commit:</strong> <code>${data.commit_sha.substring(0, 7)}</code></p>
            ${data.installation_pr && data.installation_pr.updated_at ? `
            <p><strong>PR Status Updated:</strong> ${formatRelativeTime(data.installation_pr.updated_at)}
                <span style="color: #999; font-size: 0.9em;" title="${new Date(data.installation_pr.updated_at).toLocaleString()}">(${new Date(data.installation_pr.updated_at).toLocaleString()})</span>
            </p>
            ` : ''}

            <div class="tabs" style="margin-top: 30px;">
                <button class="tab-btn active" onclick="switchTab(event, 'checks')">Check Results</button>
                ${data.service.openapi ? '<button class="tab-btn" onclick="switchTab(event, \'api\')">API Specification</button>' : ''}
                ${data.service.links && data.service.links.length > 0 ? `<button class="tab-btn" onclick="switchTab(event, 'links')">Links (${data.service.links.length})</button>` : ''}
                ${data.recent_contributors && data.recent_contributors.length > 0 ? '<button class="tab-btn" onclick="switchTab(event, \'contributors\')">Contributors</button>' : ''}
                <button class="tab-btn" onclick="switchTab(event, 'workflows')">Workflow Runs</button>
                <button class="tab-btn" onclick="switchTab(event, 'badges')">Badges</button>
            </div>

            <div class="tab-content active" id="checks-tab">
                <div>
                    ${data.checks.map(check => `
                        <div class="check-result ${check.status}">
                            <div class="check-name">
                                ${check.status === 'pass' ? '‚úì' : '‚úó'} ${escapeHtml(check.name)}
                            </div>
                            <div class="check-description">${escapeHtml(check.description)}</div>
                            ${check.stdout.trim() ? `
                                <div class="check-output">
                                    <strong>Output:</strong><br>
                                    ${escapeHtml(check.stdout.trim())}
                                </div>
                            ` : ''}
                            ${check.stderr.trim() && check.status === 'fail' ? `
                                <div class="check-output" style="color: #c62828;">
                                    <strong>Error:</strong><br>
                                    ${escapeHtml(check.stderr.trim())}
                                </div>
                            ` : ''}
                            <div style="margin-top: 8px; font-size: 0.85rem; color: #999;">
                                Weight: ${check.weight} | Duration: ${check.duration}s
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>

            ${data.service.openapi ? `
                <div class="tab-content" id="api-tab">
                    <div style="margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">OpenAPI Specification</h3>
                        ${data.service.openapi.spec_file ? `<p><strong>Spec File:</strong> <code>${escapeHtml(data.service.openapi.spec_file)}</code></p>` : ''}

                        ${data.service.openapi.environments ? `
                            <h4 style="margin-top: 20px; margin-bottom: 10px;">Environments</h4>
                            <div style="display: grid; gap: 12px;">
                                ${Object.entries(data.service.openapi.environments).map(([envName, envConfig]) => `
                                    <div style="border: 1px solid #e1e4e8; border-radius: 8px; padding: 15px; background: #f6f8fa;">
                                        <div style="font-weight: bold; margin-bottom: 5px; text-transform: capitalize;">${escapeHtml(envName)}</div>
                                        <div style="font-family: monospace; font-size: 0.9rem; color: #0366d6; margin-bottom: 5px;">
                                            ${escapeHtml(envConfig.base_url)}
                                        </div>
                                        ${envConfig.description ? `<div style="font-size: 0.85rem; color: #586069;">${escapeHtml(envConfig.description)}</div>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}

                        <div style="margin-top: 20px;">
                            <button
                                onclick="openApiExplorer('${escapeHtml(org)}', '${escapeHtml(repo)}')"
                                style="background: #0366d6; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; font-weight: 500;"
                                onmouseover="this.style.background='#0256c2'"
                                onmouseout="this.style.background='#0366d6'"
                            >
                                üîç Open API Explorer
                            </button>
                            <p style="margin-top: 10px; font-size: 0.85rem; color: #586069;">
                                Explore and test the API with an interactive Swagger UI interface
                            </p>
                        </div>
                    </div>
                </div>
            ` : ''}

            ${data.service.links && data.service.links.length > 0 ? `
                <div class="tab-content" id="links-tab">
                    <ul class="link-list">
                        ${data.service.links.map(link => `
                            <li class="link-item">
                                <a href="${escapeHtml(link.url)}" target="_blank" rel="noopener noreferrer">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="flex-shrink: 0; margin-right: 8px;">
                                        <path d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path>
                                    </svg>
                                    <div class="link-content">
                                        <strong class="link-name">${escapeHtml(link.name)}</strong>
                                        ${link.description ? `<p class="link-description">${escapeHtml(link.description)}</p>` : ''}
                                    </div>
                                </a>
                            </li>
                        `).join('')}
                    </ul>
                </div>
            ` : ''}

            ${data.recent_contributors && data.recent_contributors.length > 0 ? `
                <div class="tab-content" id="contributors-tab">
                    <h4 style="margin-top: 0; margin-bottom: 15px; font-size: 1rem; color: #2c3e50;">
                        Recent Contributors (Last 20 Commits)
                    </h4>
                    <p style="margin-bottom: 20px; color: #7f8c8d; font-size: 0.9rem;">
                        Contributors who have committed to this repository recently, ordered by commit count.
                    </p>
                    <div class="contributors-list">
                        ${data.recent_contributors.map(contributor => {
                            // Generate MD5 hash of email for Gravatar
                            const emailHash = md5(contributor.email.toLowerCase().trim());
                            const avatarUrl = `https://www.gravatar.com/avatar/${emailHash}?d=identicon&s=48`;

                            // Extract potential GitHub username from email
                            const githubUsername = contributor.email.split('@')[0].replace(/[^a-zA-Z0-9-]/g, '');
                            const isGithubEmail = contributor.email.includes('github') || contributor.email.includes('users.noreply.github.com');

                            return `
                                <div class="contributor-item">
                                    <img src="${avatarUrl}"
                                         alt="${escapeHtml(contributor.name)}"
                                         class="contributor-avatar"
                                         onerror="this.src='https://www.gravatar.com/avatar/00000000000000000000000000000000?d=mp&s=48'"
                                    >
                                    <div class="contributor-info">
                                        <div class="contributor-name">
                                            <strong>${escapeHtml(contributor.name)}</strong>
                                            ${isGithubEmail ?
                                                `<a href="https://github.com/${githubUsername}"
                                                    target="_blank"
                                                    rel="noopener noreferrer"
                                                    class="contributor-github-link"
                                                    title="View GitHub profile">
                                                    <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                                                    </svg>
                                                </a>`
                                                : ''}
                                        </div>
                                        <div class="contributor-email">${escapeHtml(contributor.email)}</div>
                                        <div class="contributor-meta">
                                            <span class="contributor-commits" title="${contributor.commit_count} commit${contributor.commit_count !== 1 ? 's' : ''}">
                                                <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle; margin-right: 4px;">
                                                    <path d="M1.643 3.143.427 1.927A.25.25 0 0 1 .604 1.5h6.792a.25.25 0 0 1 .177.427L6.357 3.143a.25.25 0 0 1-.177.073H1.82a.25.25 0 0 1-.177-.073ZM2.976 7.5A2.5 2.5 0 0 1 0 7.5v-2a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v2a2.5 2.5 0 0 1-2.024 0Zm1.524-.5h-3v.25a1.5 1.5 0 0 0 3 0V7ZM8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Z"></path>
                                                </svg>
                                                ${contributor.commit_count} commit${contributor.commit_count !== 1 ? 's' : ''}
                                            </span>
                                            <span class="contributor-date" title="${new Date(contributor.last_commit_date).toLocaleString()}">
                                                Last commit: ${formatDate(contributor.last_commit_date)}
                                            </span>
                                            <span class="contributor-hash">
                                                <code>${contributor.last_commit_hash}</code>
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            ` : ''}

            <div class="tab-content" id="workflows-tab">
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="widget-filters" style="margin: 0;">
                            <button class="widget-filter-btn active" data-status="all" onclick="filterServiceWorkflows('all')">
                                All <span class="filter-count" id="service-filter-count-all">0</span>
                            </button>
                            <button class="widget-filter-btn" data-status="in_progress" onclick="filterServiceWorkflows('in_progress')">
                                In Progress <span class="filter-count" id="service-filter-count-in_progress">0</span>
                            </button>
                            <button class="widget-filter-btn" data-status="queued" onclick="filterServiceWorkflows('queued')">
                                Queued <span class="filter-count" id="service-filter-count-queued">0</span>
                            </button>
                            <button class="widget-filter-btn" data-status="completed" onclick="filterServiceWorkflows('completed')">
                                Completed <span class="filter-count" id="service-filter-count-completed">0</span>
                            </button>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <select id="service-workflow-interval-select" class="widget-interval-select" onchange="changeServicePollingInterval()" title="Auto-refresh interval">
                                <option value="5000">5s</option>
                                <option value="10000">10s</option>
                                <option value="15000">15s</option>
                                <option value="30000" selected>30s</option>
                                <option value="60000">1m</option>
                                <option value="120000">2m</option>
                                <option value="300000">5m</option>
                                <option value="0">Off</option>
                            </select>
                            <button id="service-workflow-refresh" class="widget-refresh-btn" onclick="refreshServiceWorkflowRuns()" title="Refresh" style="padding: 6px 10px;">
                                <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                                    <path d="M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                <div id="service-workflows-content">
                    <div class="loading">Click to load workflow runs...</div>
                </div>
            </div>

            <div class="tab-content" id="badges-tab">
                <h4 style="margin-top: 0; margin-bottom: 15px; font-size: 1rem; color: #2c3e50;">Badge Preview</h4>
                <div style="background: #f5f7fa; padding: 20px; border-radius: 8px; margin-bottom: 25px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <img src="https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/score.json" alt="Score Badge" style="height: 20px;">
                    <img src="https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/rank.json" alt="Rank Badge" style="height: 20px;">
                </div>

                <h4 style="margin-bottom: 10px; font-size: 1rem; color: #2c3e50;">Add to Your README</h4>
                <p style="font-size: 0.9rem; color: #7f8c8d; margin-bottom: 10px;">
                    Copy the markdown below:
                </p>

                <div style="position: relative; margin-bottom: 15px;">
                    <button onclick="copyBadgeCode('score-badge-${org}-${repo}', event)" style="position: absolute; right: 10px; top: 10px; background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; z-index: 1;" onmouseover="this.style.background='#2980b9'" onmouseout="this.style.background='#3498db'">Copy</button>
                    <pre id="score-badge-${org}-${repo}" style="background: #f5f7fa; padding: 15px; padding-right: 80px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; margin: 0;">![Score](https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/score.json)</pre>
                </div>

                <div style="position: relative;">
                    <button onclick="copyBadgeCode('rank-badge-${org}-${repo}', event)" style="position: absolute; right: 10px; top: 10px; background: #3498db; color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; z-index: 1;" onmouseover="this.style.background='#2980b9'" onmouseout="this.style.background='#3498db'">Copy</button>
                    <pre id="rank-badge-${org}-${repo}" style="background: #f5f7fa; padding: 15px; padding-right: 80px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; margin: 0;">![Rank](https://img.shields.io/endpoint?url=${RAW_BASE_URL}/badges/${org}/${repo}/rank.json)</pre>
                </div>
            </div>
        `;

        // Re-initialize interval dropdown with saved preference
        const savedInterval = localStorage.getItem('service_workflow_poll_interval');
        if (savedInterval !== null) {
            serviceWorkflowPollIntervalTime = parseInt(savedInterval);
            const select = document.getElementById('service-workflow-interval-select');
            if (select) {
                select.value = savedInterval;
            }
        }

        showToast('Service data refreshed', 'success');

        // Restore previously active tab if it exists
        setTimeout(() => {
            const tabButtons = document.querySelectorAll('.tab-btn');
            for (const btn of tabButtons) {
                const btnText = btn.textContent.trim().toLowerCase().replace(/\s+/g, '-');
                if (btnText === activeTabName) {
                    btn.click();
                    break;
                }
            }
        }, 100);

    } catch (error) {
        console.error('Error refreshing service data:', error);
        showToast(`Failed to refresh service data: ${error.message}`, 'error');
    } finally {
        // Remove spinning animation and re-enable button
        if (button) {
            button.disabled = false;
            button.innerHTML = originalContent;
        }
    }
}

// Close Modal
function closeModal() {
    document.getElementById('service-modal').classList.add('hidden');

    // Clean up service workflow polling
    if (serviceWorkflowPollInterval) {
        clearInterval(serviceWorkflowPollInterval);
        serviceWorkflowPollInterval = null;
    }

    // Clean up service duration updates
    if (serviceDurationUpdateInterval) {
        clearInterval(serviceDurationUpdateInterval);
        serviceDurationUpdateInterval = null;
    }

    // Reset service workflow state
    currentServiceOrg = null;
    currentServiceRepo = null;
    serviceWorkflowRuns = [];
    serviceWorkflowLoaded = false;
    serviceWorkflowFilterStatus = 'all';
}

// Switch Tab
function switchTab(event, tabName) {
    // Remove active class from all tab buttons and content
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    // Add active class to clicked button and corresponding content
    event.target.classList.add('active');
    document.getElementById(`${tabName}-tab`).classList.add('active');

    // Lazy load workflow runs when workflows tab is opened
    if (tabName === 'workflows' && !serviceWorkflowLoaded) {
        loadWorkflowRunsForService();
    }
}

// ============================================================================
// Service Modal Workflow Runs Functions
// ============================================================================

// Load workflow runs for the current service
async function loadWorkflowRunsForService() {
    if (!currentServiceOrg || !currentServiceRepo) {
        return;
    }

    if (!githubPAT) {
        const content = document.getElementById('service-workflows-content');
        content.innerHTML = `
            <div class="widget-empty">
                <p style="margin-bottom: 15px;">GitHub Personal Access Token required to view workflow runs.</p>
                <button
                    onclick="openSettings()"
                    style="background: #0969da; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.95rem; font-weight: 500;"
                    onmouseover="this.style.background='#0860ca'"
                    onmouseout="this.style.background='#0969da'">
                    Set GitHub PAT
                </button>
                <p style="margin-top: 10px; font-size: 0.85rem; color: #586069;">
                    Need a PAT with <code>workflow</code> scope to view workflow runs.
                </p>
            </div>
        `;
        return;
    }

    const content = document.getElementById('service-workflows-content');
    content.innerHTML = '<div class="loading">Loading workflow runs...</div>';

    try {
        const response = await fetch(
            `https://api.github.com/repos/${currentServiceOrg}/${currentServiceRepo}/actions/runs?per_page=25&_t=${Date.now()}`,
            {
                headers: {
                    'Authorization': `token ${githubPAT}`,
                    'Accept': 'application/vnd.github.v3+json'
                },
                cache: 'no-cache'
            }
        );

        if (!response.ok) {
            throw new Error(`Failed to fetch workflow runs: ${response.status}`);
        }

        const data = await response.json();

        // Add org/repo metadata to each run
        serviceWorkflowRuns = data.workflow_runs.map(run => ({
            ...run,
            org: currentServiceOrg,
            repo: currentServiceRepo
        }));

        serviceWorkflowLoaded = true;

        // Update UI
        renderServiceWorkflowRuns();

        // Start polling for updates with configured interval
        startServiceWorkflowPolling();

    } catch (error) {
        console.error('Error fetching service workflow runs:', error);
        content.innerHTML = `
            <div class="widget-empty">
                <p style="color: #d73a49; margin-bottom: 10px;">Error loading workflow runs</p>
                <p style="font-size: 0.9rem; color: #586069;">${escapeHtml(error.message)}</p>
            </div>
        `;
    }
}

// Start or restart polling for service workflow runs
function startServiceWorkflowPolling() {
    // Clear existing interval
    if (serviceWorkflowPollInterval) {
        clearInterval(serviceWorkflowPollInterval);
        serviceWorkflowPollInterval = null;
    }

    // Only start polling if interval is not 0 (disabled) and PAT is available
    if (serviceWorkflowPollIntervalTime > 0 && githubPAT) {
        serviceWorkflowPollInterval = setInterval(() => {
            loadWorkflowRunsForService();
        }, serviceWorkflowPollIntervalTime);
    }
}

// Change service workflow polling interval
function changeServicePollingInterval() {
    const select = document.getElementById('service-workflow-interval-select');
    const newInterval = parseInt(select.value);

    // Save preference
    localStorage.setItem('service_workflow_poll_interval', newInterval);
    serviceWorkflowPollIntervalTime = newInterval;

    // Restart polling with new interval
    startServiceWorkflowPolling();

    // Provide user feedback
    if (newInterval === 0) {
        showToast('Auto-refresh disabled. Use refresh button for manual updates.', 'info');
    } else {
        const intervalText = formatInterval(newInterval);
        showToast(`Auto-refresh set to ${intervalText}`, 'success');
    }
}

// Refresh service workflow runs manually
async function refreshServiceWorkflowRuns() {
    const button = document.getElementById('service-workflow-refresh');
    if (!button) return;

    // Add spinning animation
    const svg = button.querySelector('svg');
    if (svg) {
        svg.style.animation = 'spin 1s linear infinite';
    }

    // Clear loaded flag to force fresh fetch
    serviceWorkflowLoaded = false;

    try {
        await loadWorkflowRunsForService();
        showToast('Workflow runs refreshed', 'success');
    } catch (error) {
        showToast('Failed to refresh workflow runs', 'error');
    } finally {
        // Remove spinning animation
        if (svg) {
            svg.style.animation = '';
        }
    }
}

// Render service workflow runs with current filter
function renderServiceWorkflowRuns() {
    const content = document.getElementById('service-workflows-content');

    // Filter runs based on selected status
    let filteredRuns = serviceWorkflowRuns;
    if (serviceWorkflowFilterStatus !== 'all') {
        filteredRuns = serviceWorkflowRuns.filter(run => run.status === serviceWorkflowFilterStatus);
    }

    // Update filter counts
    updateServiceFilterCounts();

    if (filteredRuns.length === 0) {
        const statusText = serviceWorkflowFilterStatus === 'all' ? '' : serviceWorkflowFilterStatus.replace('_', ' ');
        content.innerHTML = `
            <div class="widget-empty">
                <p>No ${statusText} workflow runs found</p>
            </div>
        `;
        return;
    }

    // Render workflow runs using existing renderWorkflowRun function
    content.innerHTML = filteredRuns.map(run => renderWorkflowRun(run)).join('');

    // Start live duration updates for running workflows
    if (serviceWorkflowFilterStatus === 'all' || serviceWorkflowFilterStatus === 'in_progress') {
        startServiceLiveDurationUpdates();
    }
}

// Update service filter counts
function updateServiceFilterCounts() {
    const all = serviceWorkflowRuns.length;
    const running = serviceWorkflowRuns.filter(r => r.status === 'in_progress').length;
    const queued = serviceWorkflowRuns.filter(r => r.status === 'queued').length;
    const completed = serviceWorkflowRuns.filter(r => r.status === 'completed').length;

    const allEl = document.getElementById('service-filter-count-all');
    const runningEl = document.getElementById('service-filter-count-in_progress');
    const queuedEl = document.getElementById('service-filter-count-queued');
    const completedEl = document.getElementById('service-filter-count-completed');

    if (allEl) allEl.textContent = all;
    if (runningEl) runningEl.textContent = running;
    if (queuedEl) queuedEl.textContent = queued;
    if (completedEl) completedEl.textContent = completed;
}

// Filter service workflows by status
function filterServiceWorkflows(status) {
    serviceWorkflowFilterStatus = status;

    // Update active button in the workflows tab
    const workflowsTab = document.getElementById('workflows-tab');
    if (workflowsTab) {
        workflowsTab.querySelectorAll('.widget-filter-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        const activeBtn = workflowsTab.querySelector(`[data-status="${status}"]`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        }
    }

    // Re-render content
    renderServiceWorkflowRuns();
}

// Start live duration updates for service workflows
function startServiceLiveDurationUpdates() {
    // Clear any existing interval
    if (serviceDurationUpdateInterval) {
        clearInterval(serviceDurationUpdateInterval);
    }

    // Update every second
    serviceDurationUpdateInterval = setInterval(() => {
        const serviceContent = document.getElementById('service-workflows-content');
        if (!serviceContent) {
            clearInterval(serviceDurationUpdateInterval);
            return;
        }

        const durationElements = serviceContent.querySelectorAll('.widget-run-duration');
        durationElements.forEach(el => {
            const startedAt = el.dataset.started;
            const status = el.dataset.status;

            if (startedAt) {
                const start = new Date(startedAt);
                const now = new Date();
                const durationMs = now - start;

                const timeStr = formatDuration(durationMs);

                // Add appropriate label based on status
                const label = status === 'in_progress' ? 'Running for' :
                             status === 'queued' ? 'Queued' : 'Completed';

                el.textContent = `${label} ${timeStr}`;
            }
        });
    }, 1000);
}

// Utility Functions
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function capitalize(str) {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function formatDate(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    if (diffDays === 0) return 'Today';
    if (diffDays === 1) return 'Yesterday';
    if (diffDays < 7) return `${diffDays} days ago`;
    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;

    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
}

// Open API Explorer
function openApiExplorer(org, repo) {
    // Open API explorer in a new window with the service org and repo as query params
    const explorerUrl = `api-explorer.html?org=${encodeURIComponent(org)}&repo=${encodeURIComponent(repo)}`;
    window.open(explorerUrl, '_blank');
}

// Fallback clipboard copy for non-HTTPS contexts or older browsers
function fallbackCopyToClipboard(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);
        return successful;
    } catch (err) {
        document.body.removeChild(textArea);
        return false;
    }
}

// MD5 hash function for Gravatar support
function md5(string) {
    function rotateLeft(lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    }

    function addUnsigned(lX, lY) {
        const lX8 = (lX & 0x80000000);
        const lY8 = (lY & 0x80000000);
        const lX4 = (lX & 0x40000000);
        const lY4 = (lY & 0x40000000);
        const lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
        if (lX4 & lY4) return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
        if (lX4 | lY4) {
            if (lResult & 0x40000000) return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
            else return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
        } else return (lResult ^ lX8 ^ lY8);
    }

    function F(x, y, z) { return (x & y) | ((~x) & z); }
    function G(x, y, z) { return (x & z) | (y & (~z)); }
    function H(x, y, z) { return (x ^ y ^ z); }
    function I(x, y, z) { return (y ^ (x | (~z))); }

    function FF(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    }

    function GG(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    }

    function HH(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    }

    function II(a, b, c, d, x, s, ac) {
        a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac));
        return addUnsigned(rotateLeft(a, s), b);
    }

    function convertToWordArray(string) {
        const lMessageLength = string.length;
        const lNumberOfWords_temp1 = lMessageLength + 8;
        const lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        const lWordArray = new Array(lNumberOfWords - 1);
        let lBytePosition = 0;
        let lByteCount = 0;
        while (lByteCount < lMessageLength) {
            const lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
            lByteCount++;
        }
        const lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
    }

    function wordToHex(lValue) {
        let wordToHexValue = '';
        for (let lCount = 0; lCount <= 3; lCount++) {
            const lByte = (lValue >>> (lCount * 8)) & 255;
            const wordToHexValue_temp = '0' + lByte.toString(16);
            wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
        }
        return wordToHexValue;
    }

    const x = convertToWordArray(string);
    const S11 = 7, S12 = 12, S13 = 17, S14 = 22;
    const S21 = 5, S22 = 9, S23 = 14, S24 = 20;
    const S31 = 4, S32 = 11, S33 = 16, S34 = 23;
    const S41 = 6, S42 = 10, S43 = 15, S44 = 21;

    let a = 0x67452301, b = 0xEFCDAB89, c = 0x98BADCFE, d = 0x10325476;

    for (let k = 0; k < x.length; k += 16) {
        const AA = a, BB = b, CC = c, DD = d;
        a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
        d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
        c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
        b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
        a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
        d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
        c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
        b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
        a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
        d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
        c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
        d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
        c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
        a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
        a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
        d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
        b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
        a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
        c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
        b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
        d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
        c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
        d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
        c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
        b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
        c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
        b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
        a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
        d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
        a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
        d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
        c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
        a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
        c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
        a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
        d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
        b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
        d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
        b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
        a = addUnsigned(a, AA);
        b = addUnsigned(b, BB);
        c = addUnsigned(c, CC);
        d = addUnsigned(d, DD);
    }

    return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
}

// Copy badge code to clipboard
async function copyBadgeCode(elementId, event) {
    const element = document.getElementById(elementId);
    const text = element.textContent;
    const button = event?.currentTarget || event?.target;

    try {
        // Try modern Clipboard API first (requires HTTPS or localhost)
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(text);
        } else {
            // Fallback for non-HTTPS or older browsers
            const success = fallbackCopyToClipboard(text);
            if (!success) {
                throw new Error('Fallback copy failed');
            }
        }

        // Success feedback
        if (button) {
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.style.background = '#27ae60';

            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '#3498db';
            }, 2000);
        }
    } catch (err) {
        console.error('Failed to copy:', err);

        // Provide specific error messages
        let message = 'Failed to copy to clipboard. ';
        if (!window.isSecureContext) {
            message += 'This page must be served over HTTPS.';
        } else if (err.name === 'NotAllowedError') {
            message += 'Please allow clipboard access in your browser.';
        } else {
            message += 'Please select and copy the text manually.';
        }

        alert(message);
    }
}

// ============================================================================
// Workflow Trigger Functions
// ============================================================================

// Get GitHub token - uses unified in-memory PAT
function getGitHubToken() {
    if (!githubPAT) {
        // Open settings modal to prompt user for PAT
        showToast('Please configure a GitHub PAT in Settings to trigger workflows', 'warning');
        openSettings();
        return null;
    }
    return githubPAT;
}

// Clear stored GitHub token - now clears in-memory PAT
function clearGitHubToken() {
    clearPAT();
}

// Trigger scorecard workflow for a single service
async function triggerServiceWorkflow(org, repo, buttonElement) {
    const token = getGitHubToken();

    if (!token) {
        showToast('GitHub token is required to trigger workflows', 'error');
        return false;
    }

    // Disable button and show loading state
    if (buttonElement) {
        buttonElement.disabled = true;
        buttonElement.dataset.originalText = buttonElement.textContent;
        buttonElement.innerHTML = '<span class="spinner"></span> Triggering...';
    }

    try {
        // Trigger the proxy workflow in the scorecards repository
        const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/trigger-service-workflow.yml/dispatches`,
            {
                method: 'POST',
                headers: {
                    'Accept': 'application/vnd.github+json',
                    'Authorization': `Bearer ${token}`,
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: 'main',
                    inputs: {
                        org: org,
                        repo: repo
                    }
                })
            }
        );

        if (response.status === 204) {
            // Success - workflow was triggered
            showToast(`Scorecard workflow triggered for ${org}/${repo}`, 'success');

            // Update button state
            if (buttonElement) {
                // Save original styles
                buttonElement.dataset.originalBackground = buttonElement.style.background || '';
                buttonElement.dataset.originalColor = buttonElement.style.color || '';

                // Show success state
                buttonElement.innerHTML = '‚úì Triggered Successfully';
                buttonElement.style.background = '#10b981';
                buttonElement.style.color = 'white';

                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                    buttonElement.style.background = buttonElement.dataset.originalBackground;
                    buttonElement.style.color = buttonElement.dataset.originalColor;
                }, 3000);
            }

            return true;
        } else if (response.status === 401) {
            // Invalid token
            clearPAT();
            showToast('Invalid GitHub token. Please enter a valid token in Settings.', 'error');

            // Show error state
            if (buttonElement) {
                // Save original styles
                buttonElement.dataset.originalBackground = buttonElement.style.background || '';
                buttonElement.dataset.originalColor = buttonElement.style.color || '';

                buttonElement.innerHTML = '‚úó Trigger Failed';
                buttonElement.style.background = '#ef4444';
                buttonElement.style.color = 'white';

                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                    buttonElement.style.background = buttonElement.dataset.originalBackground;
                    buttonElement.style.color = buttonElement.dataset.originalColor;
                }, 3000);
            }

            return false;
        } else {
            // Other error
            const errorData = await response.json().catch(() => ({}));
            console.error('Failed to trigger workflow:', response.status, errorData);
            showToast(`Failed to trigger workflow: ${errorData.message || response.statusText}`, 'error');

            // Show error state
            if (buttonElement) {
                // Save original styles
                buttonElement.dataset.originalBackground = buttonElement.style.background || '';
                buttonElement.dataset.originalColor = buttonElement.style.color || '';

                buttonElement.innerHTML = '‚úó Trigger Failed';
                buttonElement.style.background = '#ef4444';
                buttonElement.style.color = 'white';

                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                    buttonElement.style.background = buttonElement.dataset.originalBackground;
                    buttonElement.style.color = buttonElement.dataset.originalColor;
                }, 3000);
            }

            return false;
        }
    } catch (error) {
        console.error('Error triggering workflow:', error);
        showToast(`Error triggering workflow: ${error.message}`, 'error');

        // Show error state
        if (buttonElement) {
            // Save original styles
            buttonElement.dataset.originalBackground = buttonElement.style.background || '';
            buttonElement.dataset.originalColor = buttonElement.style.color || '';

            buttonElement.innerHTML = '‚úó Trigger Failed';
            buttonElement.style.background = '#ef4444';
            buttonElement.style.color = 'white';

            setTimeout(() => {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                buttonElement.style.background = buttonElement.dataset.originalBackground;
                buttonElement.style.color = buttonElement.dataset.originalColor;
            }, 3000);
        }

        return false;
    }
}

// Install scorecards by creating an installation PR
async function installService(org, repo, buttonElement) {
    const token = getGitHubToken();

    if (!token) {
        showToast('GitHub token is required to create installation PRs', 'error');
        return false;
    }

    // Disable button and show loading state
    if (buttonElement) {
        buttonElement.disabled = true;
        buttonElement.dataset.originalText = buttonElement.textContent;
        buttonElement.innerHTML = '<span class="spinner"></span> Creating PR...';
    }

    try {
        // Trigger the create-installation-pr workflow in the scorecards repository
        const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/create-installation-pr.yml/dispatches`,
            {
                method: 'POST',
                headers: {
                    'Accept': 'application/vnd.github+json',
                    'Authorization': `Bearer ${token}`,
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: 'main',
                    inputs: {
                        org: org,
                        repo: repo
                    }
                })
            }
        );

        if (response.status === 204) {
            // Success - workflow was triggered
            showToast(`Installation PR creation started for ${org}/${repo}`, 'success');

            // Inform user about expected delay
            setTimeout(() => {
                showToast('Note: PR status will appear in the catalog in 3-5 minutes due to GitHub Pages deployment.', 'info');
            }, 2000);

            // Update button to show pending state
            if (buttonElement) {
                buttonElement.innerHTML = '‚è≥ PR Creating...';

                // Poll for workflow completion and get PR URL
                setTimeout(async () => {
                    try {
                        // Wait a bit for the workflow to complete
                        await new Promise(resolve => setTimeout(resolve, 5000));

                        // Refresh the service details to get the new PR info
                        // The registry will be updated by the workflow
                        showToast('Installation PR created! Refreshing...', 'success');

                        // Close and reopen modal to refresh data
                        const modal = document.getElementById('service-modal');
                        modal.classList.add('hidden');
                        setTimeout(() => showServiceDetail(org, repo), 500);
                    } catch (error) {
                        console.error('Error checking PR status:', error);
                        if (buttonElement) {
                            buttonElement.disabled = false;
                            buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
                        }
                    }
                }, 1000);
            }

            return true;
        } else if (response.status === 401) {
            // Invalid token
            localStorage.removeItem('github_token');
            showToast('Invalid GitHub token. Please enter a valid token with workflow permissions.', 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
            }

            return false;
        } else {
            // Other error
            const errorData = await response.json().catch(() => ({}));
            console.error('Failed to create installation PR:', response.status, errorData);
            showToast(`Failed to create installation PR: ${errorData.message || response.statusText}`, 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
            }

            return false;
        }
    } catch (error) {
        console.error('Error creating installation PR:', error);
        showToast(`Error creating installation PR: ${error.message}`, 'error');

        // Restore button
        if (buttonElement) {
            buttonElement.disabled = false;
            buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
        }

        return false;
    }
}

// Trigger workflows for multiple services (bulk operation)
async function triggerBulkWorkflows(services, buttonElement) {
    const token = getGitHubToken();

    if (!token) {
        showToast('GitHub token is required to trigger workflows', 'error');
        return false;
    }

    // Disable button and show loading state
    if (buttonElement) {
        buttonElement.disabled = true;
        buttonElement.dataset.originalText = buttonElement.textContent;
        buttonElement.innerHTML = '<span class="spinner"></span> Triggering...';
    }

    try {
        // Prepare services array
        const servicesArray = services.map(s => ({ org: s.org, repo: s.repo }));

        // Trigger the proxy workflow with bulk services
        const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/trigger-service-workflow.yml/dispatches`,
            {
                method: 'POST',
                headers: {
                    'Accept': 'application/vnd.github+json',
                    'Authorization': `Bearer ${token}`,
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: 'main',
                    inputs: {
                        services: JSON.stringify(servicesArray)
                    }
                })
            }
        );

        if (response.status === 204) {
            // Success
            showToast(`Triggered workflows for ${services.length} service${services.length !== 1 ? 's' : ''}`, 'success');

            // Update button state
            if (buttonElement) {
                buttonElement.innerHTML = `‚úì Triggered ${services.length} service${services.length !== 1 ? 's' : ''}`;
                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
                }, 3000);
            }

            return true;
        } else if (response.status === 401) {
            // Invalid token
            clearPAT();
            showToast('Invalid GitHub token. Please enter a valid token in Settings.', 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
            }

            return false;
        } else {
            // Other error
            const errorData = await response.json().catch(() => ({}));
            console.error('Failed to trigger bulk workflows:', response.status, errorData);
            showToast(`Failed to trigger workflows: ${errorData.message || response.statusText}`, 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
            }

            return false;
        }
    } catch (error) {
        console.error('Error triggering bulk workflows:', error);
        showToast(`Error triggering workflows: ${error.message}`, 'error');

        // Restore button
        if (buttonElement) {
            buttonElement.disabled = false;
            buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
        }

        return false;
    }
}

// Handle bulk trigger button click
function handleBulkTrigger(event) {
    event.preventDefault();

    // Get all stale and installed services
    const staleServices = allServices.filter(s =>
        isServiceStale(s, currentChecksHash) && s.installed
    );

    if (staleServices.length === 0) {
        showToast('No stale services to trigger', 'info');
        return;
    }

    // Confirm with user
    if (confirm(`This will trigger scorecard workflows for ${staleServices.length} stale service${staleServices.length !== 1 ? 's' : ''}.\n\nContinue?`)) {
        triggerBulkWorkflows(staleServices, event.currentTarget);
    }
}

// ============================================================================
// Toast Notification System
// ============================================================================

// Show toast notification
function showToast(message, type = 'info') {
    // Create toast container if it doesn't exist
    let container = document.getElementById('toast-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'toast-container';
        document.body.appendChild(container);
    }

    // Create toast element
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;

    // Add icon based on type
    let icon = '';
    switch (type) {
        case 'success':
            icon = '‚úì';
            break;
        case 'error':
            icon = '‚úó';
            break;
        case 'warning':
            icon = '‚ö†';
            break;
        case 'info':
        default:
            icon = '‚Ñπ';
            break;
    }

    toast.innerHTML = `
        <span class="toast-icon">${icon}</span>
        <span class="toast-message">${escapeHtml(message)}</span>
    `;

    // Add to container
    container.appendChild(toast);

    // Trigger animation
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);

    // Remove after delay
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            container.removeChild(toast);
        }, 300);
    }, 5000);
}

// ============================================================================
// Hybrid Fetch Functions (GitHub API with PAT or raw.githubusercontent.com)
// ============================================================================

// Hybrid fetch wrapper - uses GitHub API with PAT if available, otherwise raw URLs
async function fetchWithHybridAuth(path, options = {}) {
    let response;
    let usedAPI = false;

    if (githubPAT) {
        // Try GitHub API first with PAT
        try {
            const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${path}?ref=${BRANCH}`;
            response = await fetch(apiUrl, {
                ...options,
                cache: 'no-cache',
                headers: {
                    ...options.headers,
                    'Accept': 'application/vnd.github.raw',
                    'Authorization': `token ${githubPAT}`
                }
            });

            usedAPI = true;

            // Check rate limit headers
            const remaining = response.headers.get('X-RateLimit-Remaining');
            if (remaining && parseInt(remaining) < 5) {
                showToast(`Warning: Only ${remaining} API requests remaining`, 'warning');
            }

            // Handle rate limit errors
            if (response.status === 403 || response.status === 429) {
                const rateLimitReset = response.headers.get('X-RateLimit-Reset');
                const resetTime = rateLimitReset
                    ? new Date(parseInt(rateLimitReset) * 1000).toLocaleTimeString()
                    : 'unknown';

                showToast(
                    `GitHub API rate limit exceeded. Resets at ${resetTime}. Falling back to CDN mode.`,
                    'warning'
                );

                // Fall back to raw URL
                usedAPI = false;
            } else if (response.status === 401) {
                // Invalid token - clear it
                showToast('Invalid GitHub PAT detected. Clearing token and falling back to CDN mode.', 'error');
                clearPAT();
                usedAPI = false;
            } else if (!response.ok) {
                // Other error - fall back to raw URL
                console.warn(`API fetch failed with status ${response.status}, falling back to CDN`);
                usedAPI = false;
            }
        } catch (error) {
            console.error('Error with API fetch, falling back to CDN:', error);
            usedAPI = false;
        }
    }

    // If no PAT or API failed, use raw.githubusercontent.com
    if (!usedAPI) {
        const rawUrl = `${RAW_BASE_URL}/${path}?t=${Date.now()}`;
        response = await fetch(rawUrl, {
            ...options,
            cache: 'no-cache'
        });
    }

    return {
        response,
        usedAPI
    };
}

// ============================================================================
// Settings Modal and PAT Management Functions
// ============================================================================

// Open settings modal
function openSettings() {
    const modal = document.getElementById('settings-modal');
    modal.classList.remove('hidden');

    // Update UI to reflect current PAT state
    updateModeIndicator();

    // Auto-check rate limit when opening settings
    checkRateLimit();
}

// Close settings modal
function closeSettings() {
    const modal = document.getElementById('settings-modal');
    modal.classList.add('hidden');
}

// Test if a PAT is valid
async function testPAT(pat) {
    try {
        const response = await fetch('https://api.github.com/user', {
            headers: {
                'Authorization': `token ${pat}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        return response.ok;
    } catch (error) {
        console.error('Error testing PAT:', error);
        return false;
    }
}

// Save PAT to in-memory storage
async function savePAT() {
    const input = document.getElementById('github-pat-input');
    const pat = input.value.trim();

    if (!pat) {
        showToast('Please enter a valid PAT', 'error');
        return;
    }

    // Test the PAT first
    showToast('Validating token...', 'info');
    const isValid = await testPAT(pat);

    if (isValid) {
        githubPAT = pat;
        updateWidgetState();
        updateModeIndicator();
        showToast('PAT saved successfully! Using GitHub API mode.', 'success');
        checkRateLimit(); // Update rate limit display
    } else {
        showToast('Invalid PAT. Please check and try again.', 'error');
    }
}

// Clear PAT from in-memory storage
function clearPAT() {
    githubPAT = null;
    const input = document.getElementById('github-pat-input');
    input.value = '';
    updateWidgetState();
    updateModeIndicator();
    showToast('PAT cleared. Using public CDN mode.', 'info');
    checkRateLimit(); // Update rate limit display
}

// Update the widget visual state based on PAT presence
function updateWidgetState() {
    const settingsBtn = document.getElementById('settings-btn');
    const unlockedIcon = document.querySelector('.unlocked-icon');
    const lockedIcon = document.querySelector('.locked-icon');

    if (githubPAT) {
        // PAT loaded - show locked icon
        settingsBtn.classList.add('has-token');
        unlockedIcon.style.display = 'none';
        lockedIcon.style.display = 'block';
        settingsBtn.title = 'Settings (PAT loaded)';
    } else {
        // No PAT - show unlocked icon
        settingsBtn.classList.remove('has-token');
        unlockedIcon.style.display = 'block';
        lockedIcon.style.display = 'none';
        settingsBtn.title = 'Settings';
    }
}

// Update mode indicator in settings modal
function updateModeIndicator() {
    const indicator = document.getElementById('mode-indicator');
    const currentMode = document.querySelector('.current-mode');

    if (githubPAT) {
        indicator.textContent = 'GitHub API (fast, authenticated)';
        currentMode.classList.add('api-mode');
    } else {
        indicator.textContent = 'Public CDN (slower, no rate limits)';
        currentMode.classList.remove('api-mode');
    }
}

// Check and display GitHub API rate limit status
async function checkRateLimit() {
    try {
        const headers = githubPAT
            ? { 'Authorization': `token ${githubPAT}` }
            : {};

        const response = await fetch('https://api.github.com/rate_limit', { headers });
        const data = await response.json();

        document.getElementById('rate-limit-remaining').textContent = data.rate.remaining;
        document.getElementById('rate-limit-limit').textContent = data.rate.limit;
        document.getElementById('rate-limit-reset').textContent =
            new Date(data.rate.reset * 1000).toLocaleTimeString();

        if (data.rate.remaining < 10) {
            showToast('Warning: Low rate limit remaining!', 'warning');
        }
    } catch (error) {
        console.error('Error checking rate limit:', error);
        document.getElementById('rate-limit-remaining').textContent = 'Error';
        document.getElementById('rate-limit-limit').textContent = '-';
        document.getElementById('rate-limit-reset').textContent = '-';
    }
}

// ============================================================================
// GitHub Actions Widget
// ============================================================================

// Widget State
let widgetOpen = false;
let widgetWorkflowRuns = [];
let widgetFilterStatus = 'all';
let widgetPollInterval = null;
let widgetLastFetch = 0;
let currentPollingInterval = 30000; // Default 30s, configurable
const WIDGET_POLL_INTERVAL_ACTIVE = 30000; // 30 seconds when activity detected
const WIDGET_POLL_INTERVAL_IDLE = 60000; // 60 seconds when idle
const WIDGET_CACHE_TTL = 15000; // 15 seconds cache

// Service Modal Workflow State
let currentServiceOrg = null;
let currentServiceRepo = null;
let serviceWorkflowRuns = [];
let serviceWorkflowFilterStatus = 'all';
let serviceWorkflowPollInterval = null;
let serviceWorkflowPollIntervalTime = 30000; // Default 30 seconds
let serviceWorkflowLoaded = false;
let serviceDurationUpdateInterval = null;

// Initialize widget on page load
document.addEventListener('DOMContentLoaded', () => {
    initializeActionsWidget();
});

// Initialize the widget
function initializeActionsWidget() {
    // Load saved interval preference
    const savedInterval = localStorage.getItem('widget_poll_interval');
    if (savedInterval !== null) {
        currentPollingInterval = parseInt(savedInterval);
        // Update dropdown to reflect saved value
        const select = document.getElementById('widget-interval-select');
        if (select) {
            select.value = savedInterval;
        }
    }

    // Set GitHub Actions link URL
    const actionsLink = document.getElementById('widget-actions-link');
    if (actionsLink) {
        actionsLink.href = `https://github.com/${REPO_OWNER}/${REPO_NAME}/actions`;
    }

    // Start polling if PAT is available
    if (githubPAT) {
        startWidgetPolling();
    }
}

// Toggle widget visibility
function toggleActionsWidget() {
    widgetOpen = !widgetOpen;
    const sidebar = document.getElementById('widget-sidebar');
    const toggle = document.getElementById('widget-toggle');

    if (widgetOpen) {
        sidebar.classList.add('open');
        toggle.classList.add('active');

        // Fetch data when opening if PAT is available
        if (githubPAT) {
            fetchWorkflowRuns();
        }
    } else {
        sidebar.classList.remove('open');
        toggle.classList.remove('active');
    }
}

// Start polling for workflow runs
function startWidgetPolling() {
    // Clear existing interval
    if (widgetPollInterval) {
        clearInterval(widgetPollInterval);
        widgetPollInterval = null;
    }

    // Initial fetch
    fetchWorkflowRuns();

    // If interval is 0 (disabled), don't start polling
    if (currentPollingInterval === 0) {
        console.log('Widget auto-refresh disabled by user preference');
        return;
    }

    // Set up polling with current interval
    widgetPollInterval = setInterval(() => {
        fetchWorkflowRuns();
    }, currentPollingInterval);

    console.log(`Widget polling started with ${currentPollingInterval}ms interval`);
}

// Stop polling
function stopWidgetPolling() {
    if (widgetPollInterval) {
        clearInterval(widgetPollInterval);
        widgetPollInterval = null;
    }
}

// Fetch workflow runs from GitHub Actions API
async function fetchWorkflowRuns() {
    if (!githubPAT) {
        renderWidgetEmpty('no-pat');
        return;
    }

    // Check cache
    const now = Date.now();
    if (now - widgetLastFetch < WIDGET_CACHE_TTL && widgetWorkflowRuns.length > 0) {
        console.log('Using cached workflow runs');
        return;
    }

    try {
        // Fetch workflow runs from the scorecards repository
        const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?per_page=25&_t=${Date.now()}`,
            {
                headers: {
                    'Authorization': `token ${githubPAT}`,
                    'Accept': 'application/vnd.github.v3+json'
                },
                cache: 'no-cache'
            }
        );

        if (!response.ok) {
            throw new Error(`Failed to fetch workflow runs: ${response.status}`);
        }

        const data = await response.json();

        // Add org/repo metadata to each run
        const allRuns = data.workflow_runs.map(run => ({
            ...run,
            org: REPO_OWNER,
            repo: REPO_NAME,
            service_name: 'Scorecards'
        }));

        // Filter to recent runs (last 24 hours) and sort by created_at
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        widgetWorkflowRuns = allRuns
            .filter(run => new Date(run.created_at) > oneDayAgo)
            .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

        widgetLastFetch = now;

        // Update UI
        updateWidgetBadge();
        renderWidgetContent();

    } catch (error) {
        console.error('Error fetching workflow runs:', error);
        renderWidgetEmpty('error', error.message);
    }
}

// Update widget badge count
function updateWidgetBadge() {
    const badge = document.getElementById('widget-badge');
    const activeRuns = widgetWorkflowRuns.filter(run =>
        run.status === 'in_progress' || run.status === 'queued'
    );

    badge.textContent = activeRuns.length;
    badge.style.display = activeRuns.length > 0 ? 'flex' : 'none';
}

// Render widget content based on current filter
function renderWidgetContent() {
    const content = document.getElementById('widget-content');

    // Filter runs based on selected status
    let filteredRuns = widgetWorkflowRuns;
    if (widgetFilterStatus !== 'all') {
        filteredRuns = widgetWorkflowRuns.filter(run => run.status === widgetFilterStatus);
    }

    // Update filter counts
    updateFilterCounts();

    if (filteredRuns.length === 0) {
        content.innerHTML = `
            <div class="widget-empty">
                <p>No ${widgetFilterStatus === 'all' ? '' : widgetFilterStatus} workflow runs in the last 24 hours</p>
            </div>
        `;
        return;
    }

    // Render workflow runs
    content.innerHTML = filteredRuns.map(run => renderWorkflowRun(run)).join('');

    // Start live duration updates for running workflows
    if (widgetFilterStatus === 'all' || widgetFilterStatus === 'in_progress') {
        startLiveDurationUpdates();
    }
}

// Render a single workflow run
function renderWorkflowRun(run) {
    const statusClass = run.status === 'completed'
        ? (run.conclusion === 'success' ? 'success' : run.conclusion === 'failure' ? 'failure' : 'neutral')
        : run.status;

    const statusIcon = getStatusIcon(run.status, run.conclusion);
    const durationInfo = calculateDuration(run);

    return `
        <div class="widget-run-item" data-run-id="${run.id}">
            <div class="widget-run-header">
                <span class="widget-run-status status-${statusClass}">${statusIcon}</span>
                <div class="widget-run-info">
                    <div class="widget-run-name">${escapeHtml(run.name)}</div>
                    <div class="widget-run-repo">${escapeHtml(run.org)}/${escapeHtml(run.repo)}</div>
                </div>
            </div>
            <div class="widget-run-meta">
                <span class="widget-run-duration" data-started="${run.run_started_at || run.created_at}" data-status="${run.status}">
                    ${durationInfo.label} ${durationInfo.time}
                </span>
                <a href="${run.html_url}" target="_blank" rel="noopener noreferrer" class="widget-run-link" onclick="event.stopPropagation()">
                    View
                    <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor">
                        <path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path>
                    </svg>
                </a>
            </div>
        </div>
    `;
}

// Get status icon based on status and conclusion
function getStatusIcon(status, conclusion) {
    if (status === 'in_progress') {
        return '<span class="spinner-small"></span>';
    } else if (status === 'queued') {
        return '‚è≥';
    } else if (status === 'completed') {
        if (conclusion === 'success') return '‚úì';
        if (conclusion === 'failure') return '‚úó';
        if (conclusion === 'cancelled') return '‚äò';
        return '‚óè';
    }
    return '‚óè';
}

// Helper function to format duration in milliseconds
function formatDuration(durationMs) {
    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
        return `${hours}h ${minutes % 60}m ago`;
    } else if (minutes > 0) {
        return `${minutes}m ago`;
    } else {
        return `${seconds}s ago`;
    }
}

// Calculate duration for a workflow run
function calculateDuration(run) {
    const now = new Date();

    if (run.status === 'completed') {
        // Show time since completion
        const completedAt = new Date(run.updated_at);
        const timeSince = now - completedAt;
        return {
            label: 'Completed',
            time: formatDuration(timeSince)
        };
    } else if (run.status === 'in_progress') {
        // Show running time
        const startedAt = new Date(run.run_started_at);
        const elapsed = now - startedAt;
        return {
            label: 'Running for',
            time: formatDuration(elapsed)
        };
    } else {
        // Queued - show time since creation
        const createdAt = new Date(run.created_at);
        const waiting = now - createdAt;
        return {
            label: 'Queued',
            time: formatDuration(waiting)
        };
    }
}

// Start live duration updates for running workflows
function startLiveDurationUpdates() {
    // Update every second
    setInterval(() => {
        const durationElements = document.querySelectorAll('.widget-run-duration');
        durationElements.forEach(el => {
            const startedAt = el.dataset.started;
            const status = el.dataset.status;

            if (startedAt) {
                const start = new Date(startedAt);
                const now = new Date();
                const durationMs = now - start;

                const timeStr = formatDuration(durationMs);

                // Add appropriate label based on status
                const label = status === 'in_progress' ? 'Running for' :
                             status === 'queued' ? 'Queued' : 'Completed';

                el.textContent = `${label} ${timeStr}`;
            }
        });
    }, 1000);
}

// Update filter counts
function updateFilterCounts() {
    const all = widgetWorkflowRuns.length;
    const running = widgetWorkflowRuns.filter(r => r.status === 'in_progress').length;
    const queued = widgetWorkflowRuns.filter(r => r.status === 'queued').length;
    const completed = widgetWorkflowRuns.filter(r => r.status === 'completed').length;

    document.getElementById('count-all').textContent = all;
    document.getElementById('count-running').textContent = running;
    document.getElementById('count-queued').textContent = queued;
    document.getElementById('count-completed').textContent = completed;
}

// Filter actions by status
function filterActions(status) {
    widgetFilterStatus = status;

    // Update active button
    document.querySelectorAll('.widget-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`[data-status="${status}"]`).classList.add('active');

    // Re-render content
    renderWidgetContent();
}

// Refresh widget manually
async function refreshActionsWidget() {
    const btn = document.getElementById('widget-refresh');
    btn.classList.add('spinning');

    // Clear cache
    widgetLastFetch = 0;

    // Fetch new data
    await fetchWorkflowRuns();

    // Remove spinning class
    setTimeout(() => {
        btn.classList.remove('spinning');
    }, 500);

    showToast('GitHub Actions refreshed', 'success');
}

// Helper function to format interval for display
function formatInterval(ms) {
    if (ms === 0) {
        return 'Off';
    } else if (ms < 60000) {
        return `${ms / 1000} second${ms !== 1000 ? 's' : ''}`;
    } else {
        const minutes = ms / 60000;
        return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
    }
}

// Change polling interval
function changePollingInterval() {
    const select = document.getElementById('widget-interval-select');
    const newInterval = parseInt(select.value);

    // Save preference
    localStorage.setItem('widget_poll_interval', newInterval);
    currentPollingInterval = newInterval;

    // Restart polling with new interval (if PAT is available)
    if (githubPAT) {
        startWidgetPolling();
    }

    // Provide user feedback
    if (newInterval === 0) {
        showToast('Auto-refresh disabled. Use refresh button for manual updates.', 'info');
    } else {
        const intervalText = formatInterval(newInterval);
        showToast(`Auto-refresh set to ${intervalText}`, 'success');
    }
}

// Render empty state
function renderWidgetEmpty(reason, errorMessage = '') {
    const content = document.getElementById('widget-content');

    if (reason === 'no-pat') {
        content.innerHTML = `
            <div class="widget-empty">
                <p>Configure GitHub PAT in settings to view workflow runs</p>
                <button onclick="openSettings()" class="widget-empty-btn">Open Settings</button>
            </div>
        `;
    } else if (reason === 'error') {
        content.innerHTML = `
            <div class="widget-empty">
                <p>Error loading workflow runs</p>
                <p class="widget-error-msg">${escapeHtml(errorMessage)}</p>
            </div>
        `;
    }

    // Update badge and counts
    updateWidgetBadge();
    document.getElementById('count-all').textContent = '0';
    document.getElementById('count-running').textContent = '0';
    document.getElementById('count-queued').textContent = '0';
    document.getElementById('count-completed').textContent = '0';
}

// Update widget when PAT changes
// Override the existing savePAT function to include widget update
const originalSavePAT = savePAT;
savePAT = async function() {
    await originalSavePAT.call(this);

    // Start widget polling if PAT was saved successfully
    if (githubPAT) {
        startWidgetPolling();
    }
};

// Override the existing clearPAT function to include widget update
const originalClearPAT = clearPAT;
clearPAT = function() {
    originalClearPAT.call(this);

    // Stop widget polling when PAT is cleared
    stopWidgetPolling();
    renderWidgetEmpty('no-pat');
};
