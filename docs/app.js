// Scorecards Catalog App

// Configuration
const REPO_OWNER = window.location.hostname.split('.')[0] || 'your-org';
const REPO_NAME = 'scorecards';
const BRANCH = 'catalog';
const RAW_BASE_URL = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}`;

// State (defined on window for access from ES6 modules)
window.allServices = [];
window.filteredServices = [];
window.activeFilters = new Map(); // Multi-select filters: filter -> 'include' | 'exclude'
window.currentSort = 'score-desc';
window.searchQuery = '';
window.currentChecksHash = null;
window.checksHashTimestamp = 0;

// GitHub PAT State (in-memory only)
window.githubPAT = null;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    // Load services on page load (errors are handled and displayed by loadServices)
    // Event listeners are now initialized in src/main.js
    loadServices().catch(() => {
        // Error already handled and displayed by loadServices()
    });
});

// ============================================================================
// Staleness Detection Functions
// ============================================================================

// Fetch current checks hash from catalog (generated by action)
// This uses a single source of truth instead of duplicating hash logic
async function fetchCurrentChecksHash() {
    const now = Date.now();
    const CACHE_TTL = 10 * 1000; // 10 seconds

    // Return cached value if still valid
    if (window.currentChecksHash && (now - window.checksHashTimestamp) < CACHE_TTL) {
        console.log('Using cached checks hash:', window.currentChecksHash);
        return window.currentChecksHash;
    }

    console.log('Fetching current checks hash from catalog...');

    try {
        // Fetch the pre-computed hash from the catalog branch
        // This is generated by the GitHub Action to ensure consistency
        const hashUrl = `${RAW_BASE_URL}/current-checks.json?t=${Date.now()}`;
        const response = await fetch(hashUrl, { cache: 'no-cache' });

        if (!response.ok) {
            console.error('Failed to fetch current checks hash:', response.status);
            return null;
        }

        const data = await response.json();
        const hash = data.checks_hash;

        // Update cache
        window.currentChecksHash = hash;
        window.checksHashTimestamp = now;

        console.log('Current checks hash:', hash);
        console.log('Checks count:', data.checks_count);
        console.log('Generated at:', data.generated_at);
        return hash;

    } catch (error) {
        console.error('Error fetching current checks hash:', error);
        return null;
    }
}

// Check if a service is stale (missing newer checks)
function isServiceStale(service, currentHash) {
    // If no current hash available, can't determine staleness
    if (!currentHash) {
        return false;
    }

    // Backwards compatibility: if service has no checks_hash, assume it's stale
    if (!service.checks_hash) {
        return true;
    }

    // Compare hashes
    return service.checks_hash !== currentHash;
}

// Format timestamp as relative time (e.g., "2 minutes ago")
// formatRelativeTime() - moved to src/utils/formatting.js

// Event listeners setup - moved to src/main.js

// Load Services from Registry
async function loadServices() {
    try {
        let loadedFromConsolidated = false;
        let usedAPI = false;

        // Try to load consolidated registry first (no API rate limits via CDN)
        try {
            console.log('Attempting to load consolidated registry...');
            const { response, usedAPI: fetchUsedAPI } = await fetchWithHybridAuth('registry/all-services.json');
            usedAPI = fetchUsedAPI;

            if (response.ok) {
                const registryData = await response.json();
                if (registryData.services && Array.isArray(registryData.services)) {
                    window.allServices = registryData.services;
                    window.filteredServices = [...window.allServices];
                    loadedFromConsolidated = true;
                    console.log(`Loaded ${window.allServices.length} services from consolidated registry (generated at ${registryData.generated_at})`);
                }
            }
        } catch (error) {
            console.warn('Failed to load consolidated registry, falling back to tree API:', error);
        }

        // Fallback: Use tree API to discover individual files (backward compatibility)
        if (!loadedFromConsolidated) {
            console.log('Loading services via tree API...');
            const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
            const response = await fetch(apiUrl);

            if (!response.ok) {
                throw new Error(`Failed to fetch repository tree: ${response.status}`);
            }

            const treeData = await response.json();

            // Find all registry JSON files (registry/$org/$repo.json), excluding all-services.json
            const registryFiles = treeData.tree
                .filter(item =>
                    item.path.startsWith('registry/') &&
                    item.path.endsWith('.json') &&
                    item.path !== 'registry/all-services.json'
                )
                .map(item => item.path);

            if (registryFiles.length === 0) {
                throw new Error('No services registered yet');
            }

            // Fetch all registry files in parallel using hybrid approach
            const fetchPromises = registryFiles.map(async (path) => {
                const { response, usedAPI: fetchUsedAPI } = await fetchWithHybridAuth(path);
                if (fetchUsedAPI) usedAPI = true; // Track if any fetch used API
                if (response.ok) {
                    return response.json();
                }
                return null;
            });

            const results = await Promise.all(fetchPromises);
            window.allServices = results.filter(service => service !== null);
            window.filteredServices = [...window.allServices];
            console.log(`Loaded ${window.allServices.length} services via tree API`);
        }

        // Fetch current checks hash for staleness detection
        await fetchCurrentChecksHash();

        updateStats();
        filterAndRenderServices();

        // Return whether API was used for data freshness indication
        return { usedAPI };
    } catch (error) {
        console.error('Error loading services:', error);
        document.getElementById('services-grid').innerHTML = `
            <div class="empty-state">
                <h3>No Services Found</h3>
                <p>No services have run scorecards yet, or the registry is not available.</p>
                <p style="margin-top: 10px; font-size: 0.9rem; color: #999;">
                    Error: ${error.message}
                </p>
            </div>
        `;
        // Re-throw to allow callers (like refreshData) to detect failure
        throw error;
    }
}

// Refresh data (re-fetch from catalog; uses GitHub API with PAT, otherwise CDN)
async function refreshData() {
    const refreshBtn = document.getElementById('refresh-btn');

    if (!refreshBtn) return;

    // Disable button and show loading state
    const originalText = refreshBtn.innerHTML;
    refreshBtn.disabled = true;
    refreshBtn.innerHTML = '<span class="spinner"></span> Refreshing...';

    try {
        // Show toast notification
        showToast('Refreshing service data...', 'info');

        // Clear checks hash cache to force refetch
        window.currentChecksHash = null;
        window.checksHashTimestamp = 0;

        // Reload all services
        const { usedAPI } = await loadServices();

        // Show appropriate success message based on data source
        const timestamp = new Date().toLocaleTimeString();
        if (usedAPI) {
            showToast(`Data refreshed successfully from GitHub API at ${timestamp}. (Fresh data, bypassed cache)`, 'success');
        } else {
            showToast(`Data refreshed from CDN at ${timestamp}. (Note: CDN cache may be up to 5 minutes old. Use GitHub PAT in settings for real-time data)`, 'success');
        }
    } catch (error) {
        console.error('Error refreshing data:', error);
        showToast(`Failed to refresh data: ${error.message}`, 'error');
    } finally {
        // Restore button state
        setTimeout(() => {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = originalText;
        }, 1000);
    }
}

// Filter and Render Services
function filterAndRenderServices() {
    // Filter
    window.filteredServices = window.allServices.filter(service => {
        // Multi-select filters with include/exclude (AND logic)
        if (window.activeFilters.size > 0) {
            for (const [filterName, filterState] of window.activeFilters) {
                // Determine if service matches this filter
                let matches = false;

                if (filterName === 'has-api') {
                    matches = service.has_api;
                } else if (filterName === 'stale') {
                    matches = isServiceStale(service, window.currentChecksHash);
                } else if (filterName === 'installed') {
                    matches = service.installed;
                } else if (filterName === 'platinum' || filterName === 'gold' || filterName === 'silver' || filterName === 'bronze') {
                    matches = service.rank === filterName;
                }

                // Apply include/exclude logic
                if (filterState === 'include') {
                    // Include: service must match
                    if (!matches) {
                        return false;
                    }
                } else if (filterState === 'exclude') {
                    // Exclude: service must NOT match
                    if (matches) {
                        return false;
                    }
                }
            }
        }

        // Search filter
        if (window.searchQuery) {
            const searchText = `${service.name} ${service.org} ${service.repo} ${service.team || ''}`.toLowerCase();
            if (!searchText.includes(window.searchQuery)) {
                return false;
            }
        }

        return true;
    });

    // Sort
    window.filteredServices.sort((a, b) => {
        switch (window.currentSort) {
            case 'score-desc':
                return b.score - a.score;
            case 'score-asc':
                return a.score - b.score;
            case 'name-asc':
                return a.name.localeCompare(b.name);
            case 'name-desc':
                return b.name.localeCompare(a.name);
            case 'updated-desc':
                return new Date(b.last_updated) - new Date(a.last_updated);
            default:
                return 0;
        }
    });

    renderServices();
}

// Export to window for use by ES6 modules
window.filterAndRenderServices = filterAndRenderServices;


// Utility Functions
// escapeHtml(), capitalize(), formatDate() - moved to src/utils/formatting.js

// Open API Explorer
function openApiExplorer(org, repo) {
    // Open API explorer in a new window with the service org and repo as query params
    const explorerUrl = `api-explorer.html?org=${encodeURIComponent(org)}&repo=${encodeURIComponent(repo)}`;
    window.open(explorerUrl, '_blank');
}

// Fallback clipboard copy for non-HTTPS contexts or older browsers
// Clipboard functions (fallbackCopyToClipboard, copyBadgeCode) - moved to src/utils/clipboard.js
// MD5 hash function - moved to src/utils/crypto.js

// ============================================================================
// Workflow Trigger Functions
// ============================================================================

// Get GitHub token - uses unified in-memory PAT
function getGitHubToken() {
    if (!window.githubPAT) {
        // Open settings modal to prompt user for PAT
        showToast('Please configure a GitHub PAT in Settings to trigger workflows', 'warning');
        openSettings();
        return null;
    }
    return window.githubPAT;
}

// Clear stored GitHub token - now clears in-memory PAT
function clearGitHubToken() {
    clearPAT();
}

// Trigger scorecard workflow for a single service
async function triggerServiceWorkflow(org, repo, buttonElement) {
    const token = getGitHubToken();

    if (!token) {
        showToast('GitHub token is required to trigger workflows', 'error');
        return false;
    }

    // Disable button and show loading state
    if (buttonElement) {
        buttonElement.disabled = true;
        buttonElement.dataset.originalText = buttonElement.textContent;
        buttonElement.innerHTML = '<span class="spinner"></span> Triggering...';
    }

    try {
        // Trigger the proxy workflow in the scorecards repository
        const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/trigger-service-workflow.yml/dispatches`,
            {
                method: 'POST',
                headers: {
                    'Accept': 'application/vnd.github+json',
                    'Authorization': `Bearer ${token}`,
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: 'main',
                    inputs: {
                        org: org,
                        repo: repo
                    }
                })
            }
        );

        if (response.status === 204) {
            // Success - workflow was triggered
            showToast(`Scorecard workflow triggered for ${org}/${repo}`, 'success');

            // Update button state
            if (buttonElement) {
                // Save original styles
                buttonElement.dataset.originalBackground = buttonElement.style.background || '';
                buttonElement.dataset.originalColor = buttonElement.style.color || '';

                // Show success state
                buttonElement.innerHTML = '✓ Triggered Successfully';
                buttonElement.style.background = '#10b981';
                buttonElement.style.color = 'white';

                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                    buttonElement.style.background = buttonElement.dataset.originalBackground;
                    buttonElement.style.color = buttonElement.dataset.originalColor;
                }, 3000);
            }

            return true;
        } else if (response.status === 401) {
            // Invalid token
            clearPAT();
            showToast('Invalid GitHub token. Please enter a valid token in Settings.', 'error');

            // Show error state
            if (buttonElement) {
                // Save original styles
                buttonElement.dataset.originalBackground = buttonElement.style.background || '';
                buttonElement.dataset.originalColor = buttonElement.style.color || '';

                buttonElement.innerHTML = '✗ Trigger Failed';
                buttonElement.style.background = '#ef4444';
                buttonElement.style.color = 'white';

                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                    buttonElement.style.background = buttonElement.dataset.originalBackground;
                    buttonElement.style.color = buttonElement.dataset.originalColor;
                }, 3000);
            }

            return false;
        } else {
            // Other error
            const errorData = await response.json().catch(() => ({}));
            console.error('Failed to trigger workflow:', response.status, errorData);
            showToast(`Failed to trigger workflow: ${errorData.message || response.statusText}`, 'error');

            // Show error state
            if (buttonElement) {
                // Save original styles
                buttonElement.dataset.originalBackground = buttonElement.style.background || '';
                buttonElement.dataset.originalColor = buttonElement.style.color || '';

                buttonElement.innerHTML = '✗ Trigger Failed';
                buttonElement.style.background = '#ef4444';
                buttonElement.style.color = 'white';

                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                    buttonElement.style.background = buttonElement.dataset.originalBackground;
                    buttonElement.style.color = buttonElement.dataset.originalColor;
                }, 3000);
            }

            return false;
        }
    } catch (error) {
        console.error('Error triggering workflow:', error);
        showToast(`Error triggering workflow: ${error.message}`, 'error');

        // Show error state
        if (buttonElement) {
            // Save original styles
            buttonElement.dataset.originalBackground = buttonElement.style.background || '';
            buttonElement.dataset.originalColor = buttonElement.style.color || '';

            buttonElement.innerHTML = '✗ Trigger Failed';
            buttonElement.style.background = '#ef4444';
            buttonElement.style.color = 'white';

            setTimeout(() => {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run Scorecard';
                buttonElement.style.background = buttonElement.dataset.originalBackground;
                buttonElement.style.color = buttonElement.dataset.originalColor;
            }, 3000);
        }

        return false;
    }
}

// Install scorecards by creating an installation PR
async function installService(org, repo, buttonElement) {
    const token = getGitHubToken();

    if (!token) {
        showToast('GitHub token is required to create installation PRs', 'error');
        return false;
    }

    // Disable button and show loading state
    if (buttonElement) {
        buttonElement.disabled = true;
        buttonElement.dataset.originalText = buttonElement.textContent;
        buttonElement.innerHTML = '<span class="spinner"></span> Creating PR...';
    }

    try {
        // Trigger the create-installation-pr workflow in the scorecards repository
        const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/create-installation-pr.yml/dispatches`,
            {
                method: 'POST',
                headers: {
                    'Accept': 'application/vnd.github+json',
                    'Authorization': `Bearer ${token}`,
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: 'main',
                    inputs: {
                        org: org,
                        repo: repo
                    }
                })
            }
        );

        if (response.status === 204) {
            // Success - workflow was triggered
            showToast(`Installation PR creation started for ${org}/${repo}`, 'success');

            // Inform user about expected delay
            setTimeout(() => {
                showToast('Note: PR status will appear in the catalog in 3-5 minutes due to GitHub Pages deployment.', 'info');
            }, 2000);

            // Update button to show pending state
            if (buttonElement) {
                buttonElement.innerHTML = '⏳ PR Creating...';

                // Poll for workflow completion and get PR URL
                setTimeout(async () => {
                    try {
                        // Wait a bit for the workflow to complete
                        await new Promise(resolve => setTimeout(resolve, 5000));

                        // Refresh the service details to get the new PR info
                        // The registry will be updated by the workflow
                        showToast('Installation PR created! Refreshing...', 'success');

                        // Close and reopen modal to refresh data
                        const modal = document.getElementById('service-modal');
                        modal.classList.add('hidden');
                        setTimeout(() => showServiceDetail(org, repo), 500);
                    } catch (error) {
                        console.error('Error checking PR status:', error);
                        if (buttonElement) {
                            buttonElement.disabled = false;
                            buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
                        }
                    }
                }, 1000);
            }

            return true;
        } else if (response.status === 401) {
            // Invalid token
            localStorage.removeItem('github_token');
            showToast('Invalid GitHub token. Please enter a valid token with workflow permissions.', 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
            }

            return false;
        } else {
            // Other error
            const errorData = await response.json().catch(() => ({}));
            console.error('Failed to create installation PR:', response.status, errorData);
            showToast(`Failed to create installation PR: ${errorData.message || response.statusText}`, 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
            }

            return false;
        }
    } catch (error) {
        console.error('Error creating installation PR:', error);
        showToast(`Error creating installation PR: ${error.message}`, 'error');

        // Restore button
        if (buttonElement) {
            buttonElement.disabled = false;
            buttonElement.textContent = buttonElement.dataset.originalText || 'Install Scorecards';
        }

        return false;
    }
}

// Trigger workflows for multiple services (bulk operation)
async function triggerBulkWorkflows(services, buttonElement) {
    const token = getGitHubToken();

    if (!token) {
        showToast('GitHub token is required to trigger workflows', 'error');
        return false;
    }

    // Disable button and show loading state
    if (buttonElement) {
        buttonElement.disabled = true;
        buttonElement.dataset.originalText = buttonElement.textContent;
        buttonElement.innerHTML = '<span class="spinner"></span> Triggering...';
    }

    try {
        // Prepare services array
        const servicesArray = services.map(s => ({ org: s.org, repo: s.repo }));

        // Trigger the proxy workflow with bulk services
        const response = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/trigger-service-workflow.yml/dispatches`,
            {
                method: 'POST',
                headers: {
                    'Accept': 'application/vnd.github+json',
                    'Authorization': `Bearer ${token}`,
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: 'main',
                    inputs: {
                        services: JSON.stringify(servicesArray)
                    }
                })
            }
        );

        if (response.status === 204) {
            // Success
            showToast(`Triggered workflows for ${services.length} service${services.length !== 1 ? 's' : ''}`, 'success');

            // Update button state
            if (buttonElement) {
                buttonElement.innerHTML = `✓ Triggered ${services.length} service${services.length !== 1 ? 's' : ''}`;
                setTimeout(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
                }, 3000);
            }

            return true;
        } else if (response.status === 401) {
            // Invalid token
            clearPAT();
            showToast('Invalid GitHub token. Please enter a valid token in Settings.', 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
            }

            return false;
        } else {
            // Other error
            const errorData = await response.json().catch(() => ({}));
            console.error('Failed to trigger bulk workflows:', response.status, errorData);
            showToast(`Failed to trigger workflows: ${errorData.message || response.statusText}`, 'error');

            // Restore button
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
            }

            return false;
        }
    } catch (error) {
        console.error('Error triggering bulk workflows:', error);
        showToast(`Error triggering workflows: ${error.message}`, 'error');

        // Restore button
        if (buttonElement) {
            buttonElement.disabled = false;
            buttonElement.textContent = buttonElement.dataset.originalText || 'Re-run All Stale';
        }

        return false;
    }
}

// Handle bulk trigger button click
function handleBulkTrigger(event) {
    event.preventDefault();

    // Get all stale and installed services
    const staleServices = window.allServices.filter(s =>
        isServiceStale(s, window.currentChecksHash) && s.installed
    );

    if (staleServices.length === 0) {
        showToast('No stale services to trigger', 'info');
        return;
    }

    // Confirm with user
    if (confirm(`This will trigger scorecard workflows for ${staleServices.length} stale service${staleServices.length !== 1 ? 's' : ''}.\n\nContinue?`)) {
        triggerBulkWorkflows(staleServices, event.currentTarget);
    }
}

// ============================================================================
// Toast Notification System
// ============================================================================

// Show toast notification
// Toast notification function - moved to src/ui/toast.js

// Service Modal Workflow State
let currentServiceOrg = null;
let currentServiceRepo = null;
let serviceWorkflowRuns = [];
let serviceWorkflowFilterStatus = 'all';
let serviceWorkflowPollInterval = null;
let serviceWorkflowPollIntervalTime = 30000; // Default 30 seconds
let serviceWorkflowLoaded = false;
let serviceDurationUpdateInterval = null;
